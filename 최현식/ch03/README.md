
동적 메모리 할당과 가비지 컬렉션 기술을 처음 사용한 언어는 1960년대 MIT에서 개발된 리스프이다.

가비지 컬렉션이 처리해야하는 문제? (리스프의 창시자인 존 멕카시)
- 어떤 메모리를 회수해야 하나?
- 언제 회수해야 할까?
- 어떻게 회수해야 할까? 

'가비지 컬렉션', '메모리 할당의 내부'를 이해하여 적절히 모니터링하고 조율해야 아래 상황에 대처할 수 있음
- 다양한 메모리 오버플로와 누수 문제를 해결해야하는 상황
- 더 높은 동시성을 달성하는 데 가비지 컬렉션이 방해가 되는 상황

## 자바 언어에서
### PC, 가상머신 스택, 네이티브 메서드
- 이 영역의 메모리 할당과 회수는 결정적이라서 어떻게 회수할지 고민하지 않아도 됨
- 메서드가 끝나거나 스레드가 종료되면 자연스럽게 회수 됨 
- 프로그램 카운터, 가상 머신 스택, 네이티브 메서드 스택은 스레드와 함께 생성되고 소멸됨
- 메서드에 진입하고 바져나올 때는 스택 메모리에 스택프레임을 푸시하고 팝
- 스택 프레임에 할당되는 메모리 크기는 기본적으로 클래스가 만들어질때 결정됨 (JIT컴파일러가 런타임에 최적화하는 경우가 있지만 현재는 논외로 함)
### 힙, 메서드 영역
- 불확실한 영역, 같은 인터페이스라 해도 구현한 클래스마다 요구하는 메모리 크기가 다름
- 따라서 해당 영역의 할당과 회수는 동적으로 이루어짐 
- 가비지 컬렉터는 이 영역을 관리하는데 집중 함
- 하나의 메서드에서도 어떤 조건 분기를 실행하느냐에 따라 메모리 요구량이 달라짐
- 프로그램이 어떤 객체를 생성할지, 얼마나 많이 만들지는 오직 `런타임`에서만 알 수 있음 

<br/>

# 대상이 죽었는가?

가비지컬렉터가 힙을 청소하려면 어떤 객체가 살아있고, 또 어떤 객체가 죽었는지 판단해야 함
- 죽었다 = 프로그램 코드에서 어떤 식으로도 더는 사용될 수 없다는 뜻
- 메모리 영역들이 어떻게 구분되는지는 가상머신 구현체에 따라 다르지만, 영역들이 서로 완전히 격리되거나 닫혀있지 않다는 점을 유의

## 참조 카운팅 알고리즘
- 자바 가상 머신에서는 참조 카운팅을 사용하지 않음
- 알고리즘 진행
    - 객체를 가리키는 참조 카운터를 추가하고, 참조하는 곳이 몇개인지 카운트
    - 카운터 값이 0이 된 객체는 더는 사용될 수 없다.
- 간단한 참조 카운팅만으로는 순환 참조(circular reference) 문제를 풀기 어려움

## 도달 가능성 분석 알고리즘
- 자바, C# 등 오늘날의 주류 프로그래밍 언어들은 모두 객체 생사 판단에 도달 가능성 분석 알고리즘을 이용
- 기본 아이디어는 GC루트라고 하는 루트 객체들을 시작노드 집합으로 쓰는 것
- 알고리즘 진행
    - 시작 노드들에서 출발하여 참조하는 다른 객체들로 탐색해 들어감
    - 탐색 과정에서 만들어지는 경로를 참조 체인이라 함
    - 어떤 객체와 GC루트 사이를 이어주는 참조체인이 없다면, 도달 불가능하다 판단
- 주의점
    - GC루트가 너무 많아지지 않도록 다양한 최적화를 진행해야함 (가상머신 구현체)


```ad-question
title: 누가 GC루트가 될 수 있는가?
- 가상 머신 스택에서 참조하는 객체: 현재 실행 중인 메서드에서 쓰는 매개변수, 지역변수, 임시변수 등
- 메서드 영역에서 클래스가 정적 필드로 참조하는 객체: 자바 클래스의 참조 타입 정적 변수
- 메서드 영역에서 상수로 참조되는 객체: 문자열 테이블 안의 참조
- 네이티브 메서드 스택에서 JNI가 참조하는 객체
- 자바 가상 머신 내부에서 쓰이는 참조: 기본 데이터 타입에 해당하는 Class객체, 일부 상주 예외 객체, 시스템 클래스 로더
- 동기화 락(synchronized 키워드)로 잠겨있는 모든 객체
- 자바 가상 머신 내부 상황을 반영하는 JMXBean: JVMTI에 등록된 콜백, 로컬 코드 캐시 등
- 가비지 컬레겉 종류나 현재 회수 중인 메모리 영역에 따라 다른 객체들도 '임시로' 추가 될 수 있음
```

## 다시 참조 이야기로
### JDK 1.2 전의 자바 '참조' 정의
'참조됐다', '참조되지 않았다'
> 참조 타입 데이터에 저장된 값이 다른 메모리 조각의 시작 주소를 뜻한다면, 이 참조 데이터를 해당 메모리 조각이나 객체를 참조한다고 말한다.

### 현시점에서의 '참조'
'강한 참조', '부드러운 참조', '약한 참조', '유령 참조', '파이널 참조' 
- **강한 참조**
    - 가장 전통적인 정의의 참조를 뜻함
    - Object obj = new Object() 처럼 프로그램 코드에서 참조를 할당하는 것
    - 강한 참조 관계가 남아있는 객체는 가비지컬렉터가 절대 회수하지 않음
- **부드러운 참조**
	- 유용하지만 필수는 아닌 객체를 표현
	- 메모리 오버플로가 나기 직전에, 두번째 회수를 위한 회수 목록에 추가됨
	- 두번째 회수 후에도 메모리가 부족하다면 그때 메모리 오버플로 예외를 던짐
	- JDK 1.2 때 SoftReference 클래스 형태로 추가 됨
- **약한 참조**
	- 다음번 가비지 컬렉션까지만 살아 남는다.
	- 가비지 컬렉터가 동작하기 시작하면 메모리가 넉넉하더라도 약한 참조 객체는 모두 회수됨
	- JDK 1.2 때 WeakReference 클래스가 구현됨
- **유령 참조**
	- 참조 중에 가장 약함 (phantom/ghost reference 라고 함)
	- 유령 참조를 거는 유일한 목적은 대상 객체가 회수될 때 알림을 받기 위해서!
	- JDK 1.2 때 PhantomReference 클래스가 구현됨
- **파이널 참조**
	- JDK 내부적으로 사용되는 참조의 형태 (약한 참조와 유령 참조 사이 수준)
	- finalize() 메서드를 구현한 객체는 모두 파이널 참조의 대상이 되어 대기열(queue)에 등록됨
	- 강한 참조, 부드러운 참조, 약한 참조가 모두 제거되는 순간에 finalize() 메서드를 호출하는 용도

## 회수 대상 선정 과정
'도달 불가능'으로 판단한 객체는 '유예' 단계에 진입하게 되며, 두 번의 확인 이후에 회수 대상이 된다.

### 도달 가능성 분석 
1. **GC 루트와 연결된 참조 체인을 찾지 못한 객체**에는 첫번째 표시가 이루어짐
	1. 첫번째 표시 대상에 대해 '종료자(finalizer), 즉 finalize() 메서드를 실행해야 하는 객체인가?' 확인
2. **finalize()가 필요없는 객체이거나 가상머신이 이미 finalize()를 호출한 경우** '회수 대상'으로 처리
	1. finalize()를 실행해야 하는 객체라면 F-Queue 대기열에 추가
3. 가상 머신은 우선순위가 낮은 종료자 스레드를 생성해 F-Queue에 들어있는 객체들의 finalize() 메서드를 실행
	1. 가상 머신은 무한 루프 등에 빠질 위험으로 인해 이 메서드를 시작만 시킬 뿐, 끝날 때까지 기다려 주진 않는다.
4. finalize() 메서드를 통해, 참조 체인상의 아무 객체와 다시 연결하면 회수 대상에서 제외 됨
	1. 하지만 실행 비용이 높고 불확실성이 크기 때문에 사용하지 않는 것을 추천 (어느 객체부터 호출 될지, 로직이 완벽하게 수행될지 보장할 수 없음)
	2. finalize() 메서드는 JDK 9부터 deprecated 됨

## 메서드 영역 회수
- 더 이상 사용되지 않는 '상수', '클래스'를 회수한다.
- 메서드 영역 가비지 컬렉션은 회수 조건이 까다로워 '비용 효율'이 좋지 않음
	- 자바 힙을 신세대 GC로 처리하는 경우 '메모리 공간의 70~99%'를 회수해 내는 것에 비해
### 상수 회수
- 상수풀에서 리터럴을 회수하는 경우, 어떠한 객체도 상수를 참조하고 있지 않은 경우 회수를 진행한다.
- 상수풀에 문자열, 다른 클래스 및 인터페이스, 메서드, 필드의 심벌 참조 등이 여기에 속함
### 클래스 회수
- 세가지 조건을 만족해야 '더 이상 쓰이지 않는 클래스'라고 판단한다.
	- 이 클래스의 인스턴스가 모두 회수되었다. 즉, 자바 힙에는 해당 클래스와 하위 클래스의 인스턴스가 하나도 존재하지 않는다.
	- 이 클래스를 읽어 들인 클래스 로더가 회수되었다. 이 조건은 OSGi나 JSP 리로딩처럼 세심하게 설계된 대안 클래스 로더 없이는 충족하기 어렵다.
	- 이 클래스에 해당하는 java.lang.Class 객체를 아무 곳에서도 참조하지 않고, 리플렉션 기능으로 이 클래스의 메서드를 이용하는 곳도 전혀 없다. 
- JVM은 위 조건들에 만족하는 클래스들을 회수하도록 '허용'한다.
	- 리플렉션, 동적 프록시, CGLib 같은 바이트코드 프레임워크를 많이 사용하는 경우, JSP를 동적으로 생성하고 클래스 로더를 자주 사용자화하는 OSGI환경 등에서는 일반적으로 JVM이 타입 언로딩을 지원해야한다. → 메서드 영역이 과도한 압박에 시달리는 일을 막을 수 있음  

<br/>


# 가비지 컬렉션 알고리즘
객체의 생사를 판별하는 방식을 기주으로 가비지 컬렉션 알고리즘을 ‘참조 카운팅 GC(직접 가비지 컬렉션)’와 ‘추적 GC(간접 가비지 컬렉션)’로 나눌 수 있다. 아래에서 다루는 것은 모두 참조 카운팅 GC에 속한 알고리즘이다.

## 세대 단위 컬렉션 이론
현재 상용 가상 머신들이 채택한 가비지 컬렉터는 대부분 세대 단위 컬렉션 이론에 기초해 설계된다. 아래 이론에 따라 설계한 힙은 신세대, 구세대 최소 두개의 영역으로 나뉜다. 
1. 약한 세대 가설
	- 대다수 객체는 일찍 죽는다.
	- 신세대에서는 가비지 컬렉션 때마다 다수의 객체가 죽고 살아남은 소수만 구세대로 승격됨
2. 강한 세대 가설
	- 가비지컬렉션 과정에서 살아남은 횟수가 늘어날수록 더 오래 살 가능성이 커진다.

### 세번째 경험법칙
- 객체들은 단독으로 존재하는게 아니기 때문에 다른 세대에 존재하는 객체들을 참조하는 상황이 자연스럽게 발생한다.
- 예를 들어 신세대에서만 GC를 진행하고 싶더라도, 구세대를 참조 중인 객체도 존재함에 따라 모든 메모리를 탐색해야하 신뢰성있는 결과를 얻을 수 있게 된다. → 성능면에서 부담
1. 세대 간 참조 가설
	1. 세대 간 참조의 개수는 같은 세대 안에서의 참조보다 훨씬 적다.
	2. 상호 참조 관계의 두 객체는 삶과 죽음을 함께하는 경향이 있다.
	3. 따라서 대부분의 경우에 세대 간 참조를 하는 경우는 매우적으며, 이를 전문적으로 관리하는 것은 매우 비효율적이다. → 신세대에 기억 집합이라는 전역 데이터구조를 하나 두고 세대 간 참조를 관리한다. (런타임에 수행할 일이 증가하지만, 여전히 전체 세대를 훑는 비용보다 저렴하다.)

## 마크-스윕 알고리즘
![image](https://github.com/user-attachments/assets/49b25ada-9e27-4fe0-9ba8-2d8c42768125)

- 최초이자 가장 기본적인 가비지컬렉션 알고리즘
- 회수할 객체들에 모두 표시(mark)한 다음, 표시된 객체들을 쓸어 담는(sweep)식
### 장점
- GC 과정이 매우 간단하다. 
### 단점
- 실행 효율이 일정하지 않다.
	- 자바 힙의 대부분이 회수 대상이라면 mark, sweep 작업 모두 큰 작업이 되며 효율이 떨어진다.
	- 즉, 객체가 많아질수록 선형적으로 작업 효율이 떨어진다.
- 메모리 파편화가 심하다.
	- GC 작업 이후에는 불연속적인 메모리 파편이 만들어진다.
	- 파편화가 심한경우 프로그램이 큰 객체를 만들려 할 때 연속된 메모리를 찾지 못해 또 다른 GC 작업을 유발한다.

## 마크-카피 알고리즘
![image](https://github.com/user-attachments/assets/84701732-1a4f-4b38-b530-dde336aa4896)

- 간단히 카피 알고리즘이라고도 한다.
- 회수할 객체가 많아질수록 효율이 떨어지는 마크-스윕 알고리즘의 문제를 해결하기 위해 등장했으며, 메모리를 크게 두 영역으로 나눈다.
- 한쪽 블록이 꽉차면 살아남은 객체들만 다른 블록에 복사하고 기존 블록을 한번에 청소한다.
- 오늘날 상용 JVM 대부분은 신세대에 이 알고리즘을 사용한다. (아펠 스타일로 에덴 영역과 생존자 공간을 비율적으로 나누어 사용)
### 장점
- 메모리 파편화 문제가 해결된다.
- 구현하기 쉬우며, 실행 효율도 좋다.
### 단점
- 가용 메모리를 절반만 사용할 수 있어 메모리 낭비가 있다.

```ad-info
title: 아펠 스타일 컬렉션 방식
![image](https://github.com/user-attachments/assets/de3dd01d-dd3a-4ad8-b891-b24855f5d2f7)

신세대를 하나의 큰 에덴 공간과 두 개의 작은 생존자 공간으로 나눈다. 그리고 메모리를 할당할 때는 생존자 공간 중 하나와 에덴만 사용한다. GC는 에덴과 생존자 공간에서 살아남은 객체들을 나머지 생존자 공간으로 복사한 후 '에덴', '이전 생존자 공간'을 모두 지운다.
- 핫스팟 가상 머신에서 에덴과 생존자 공간의 비율은 기본적으로 8(에덴):1(생존자A):1(생존자B)이다. 따라서 낭비되는 공간은 10%이다. 
- 만약 10%(생존자 영역의 크기)를 넘는 크기의 객체들이 생존한 경우에는 다른 메모리 영역(보통 구세대)을 활용해 메모리 할당을 보증한다. (핸들 승격) -> 즉, 객체들을 구세대에 바로 추가한다.
```

## 마크-컴팩트 알고리즘
![image](https://github.com/user-attachments/assets/a14c9ab2-04d4-45a5-91de-ffb275347552)

마크-카피 알고리즘은 객체 생존율이 높을수록 복사할게 많아져 효율이 나빠진다. 또한 대다수 객체가 살아남는 극단적 상황에 대처해야하는데 이는 구세대 영역에는 적합하지 않다. 이를 해결하기 위해 마크-컴팩트 알고리즘이 제안되었다.
- 마크-스윕 알고리즘과 동일하게 mark 작업을 거친다.
- 생존한 모든 객체를 메모리 영역의 한쪽 끝으로 모은 다음 나머지 공간을 한번에 비운다.
- 마크-스윕 알고리즘과는 다르게 메모리 영역이 이동한다는 차이가 있다. 이동된 객체들을 가리키던 기존 참조들을 모두 갱신해줘야하는데, 이 작업은 애플리케이션을 모두 멈춘 상태에서 진행해야한다. (스탑더월드)
### 장점
- 메모리를 효율적으로 사용할 수 있다.
- 메모리 파편화가 발생하지 않는다. (메모리가 정렬되어있어 추후 메모리 할당이 편함)
### 단점
- 객체들이 메모리에서 이동하므로, 그 객체들을 참조하고있는 경우의 메모리를 모두 수정해줘야한다. (스탑더월드)
- 따라서 상대적으로 GC 과정이 복잡하다. 
- 하지만 GC 작업보다 메모리 할당/접근하는 빈도가 더 크므로 지연시간보다 처리량이 더 중요한 경우에는 적합하다. 



# 참고자료
- 리처드 존슨 - The Garbage Collection HandBook 2~4장 참고 
- 알고리즘 별 메모리 : https://abiasforaction.net/understanding-jvm-garbage-collection-part-2/































