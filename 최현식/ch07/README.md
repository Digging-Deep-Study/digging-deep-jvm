클래스를 로드하는 다섯 단계(로딩, 검증, 준비, 해석 ,초기화)를 소개하고, 클래스 로더 동작 방식과 의미를 설명

목표: 클래스 파일에서 클래스를 기술하는 방식과 가상 머신이 클래스를 읽어들이는 방법을 체계적으로 이해


클래스 파일에 서술된 정보를 가상 머신이 이용하려면 먼저 로드해야 한다. 
이번 장에서는 가상 머신이 클래스 파일을 로드하는 방법과 그 정보를 가상 머신 안에서 활용하는 방법을 다룬다.

자바 가상 머신
- 클래스 파일로부터 

### 클래스 로딩 메커니즘
JVM이 클래스 파일로부터 클래스를 설명하는 데이터를 메모리로 읽어들이고 그 데이터를 검증, 변환, 초기화하고 나서 최종적으로 가상 머신이 곧바로 사용할 수 있는 자바 타입을 생성하는 일련의 과정

자바 언어에서는 클래스 로딩, 링킹, 초기화가 모두 '런타임'에 이루어짐
따라서 자바 언어는 AOT 컴파일에 제약이 생기고, 클래스 로딩시간만큼 실행 성능이 떨어짐
하지만 이를 통해 자바 애플리케이션의 높은 확장성과 유연성을 가능케 하는 이점이 생김 ← 동적 로딩 및 링킹
→ 인터페이스 중심으로 애플리케이션을 설계하면 구현 클래스를 결정하는 것을 실행시까지 미룰 수 있음
→ 클래스로더를 활용하면 실행 중인 프로그램의 코드 일부를 네트워크를 통해 바이너리 스트림으로 읽어올 수 있음  
→ JSP, OSGi 기술 등에서 이를 활용








# 클래스 로딩 시점
타입(클래스 또는 인터페이스)의 생애주기는 로딩 → 검증 → 준비 → 해석 → 초기화 → 사용 → 언로딩 이다.
여기서 검증, 준비, 해석 단계를 '링킹'이라고 한다. 

![image](https://github.com/user-attachments/assets/19ce3e0f-9a6a-4d94-b0b5-9b32b7afc54e)

각 생애주기의 순서는 '완료'가 아닌 '시작'을 나타낸다. 즉, 하나의 단계가 완료되기 전에 다음 단계를 호출해 시작시키는 등, 병렬로 진행되기도 한다.

### 해석 단계
해석 단계는 초기화 후에 시작할 수 있다!
자바 언어의 런타임 바인딩을 지원하기 위해, 해석 단계는 초기화 이후 시점에 이뤄질 수도 있다.

### 초기화 단계
초기화가 즉시 시작되야하는 여섯가지 상황을 'JVM 명세'에 엄격히 규정했다.

**능동 참조**
1. 바이트 코드 명령어 new, getstatic, putstatic, invokestatic을 만났을 때
2. 표준 클래스 라이브러리(class 클래스 또는 reflect 패키지 등)에서 제공하는 리플렉션 메서드를 사용할 때, 해당 타입이 아직 초기화되어 있지 않은 경우
3. 상위 클래스가 초기화 되어있지 않은 경우
4. main() 메서드를 포함하는 클래스나 인터페이스에 대한 초기화
5. java.lang.invoke.MethodHandle 인스턴스를 호출할 때, 해당 클래스가 초기화되어있지 않은 경우
6. Default 메서드를 정의한 경우, 해당 인터페이스를 직간접적으로 구현한 클래스가 초기화될 때, 인터페이스 부터 초기

**수동 참조**
위 여섯가지 상황에 해당하지 않는 모든 참조 방식








# 클래스 로딩 처리 과정



### 로딩
자바 가상 머신에 내장된 부트스트랩 클래스 로더를 사용하거나 사용자 정의 클래스 로더를 사용하여 수행할 수 있다. 로딩 단계가 끝나면 BinaryByteStream은 메서드 영역에 저장된다.마지막으로 자바 힙에 클래스 객체를 초기화한다. 

단계
1. 완전한 이름을 보고 해당 클래스를 정의하는 바이너리 바이트 스트림을 가져옴
	1. zip 파일로부터 로딩
	2. 네트워크로부터 로딩
	3. 런타임에 동적으로 생성
	4. 다른파일(예를들어 jsp)로 부터 생성
2. 바이트 스트림으로 표현된 정적인 저장 구조를 메서드 영역에서 사용하는 런타임 데이터 구조로 변환
3. 로딩 대상 클래스를 표현하는 java.lang.Class 객체를 힙 메모리에 생성

```ad-tip
title: 배열클래스 로딩
배열클래스는 클래스로더가 생성하지 않고, JVM이 직접 메모리에 동적으로 생성한다. 단, 배열클래스의 원소타입은 클래스 로더를 통해 로드된다.
```

### 링킹 - 검증
검증 과정은 바이트스트림에 오류가 있거나 악의적으로 작성된 바이트코드 스트림이 로드되어 시스템을 해치는 것을 막기위한 과정이다.
	1. 클래스 파일의 바이트 스트림에 담긴 정보가 명세에서 규정한 모든 제약을 만족하는지 확인
	2. 이 정보를 코드로 변환해 실행했을 때, JVM 자체의 보안을 위협하지 않는지 확인

검증단계는 중요하지만 필수는 아니다. 따라서 프로그램이 실행하는 모든 코드를 신뢰할 수 있다면 검증을 건너뛰기도 한다. (클래스 로딩 시간 단축!)

아래 네가지 검증을 진행하게된다. (파일 형식 검증, 메타데이터 검증, 바이트코드 검증, 심벌 참조 검증)

**파일 형식 검증**
바이트 스트림이 클래스파일 형식에 부합하고 현재 버전의 가상머신에서 처리될 수 있는지 확인

**메타데이터 검증**
바이트코드로 설명된 정보의 의미를 분석하여, 서술된 정보가 명세의 요구사항을 충족하는지 확인

**바이트코드 검증**
클래스의 메서드 본문(클래스 파일의 code 속성)을 분석하여, 메서드가 런타임에 가상 머신의 보안을 위협하는 동작을 하는지 확인한다.
(전체 검증 과정에서 가장 복잡한 단계)

**심벌 참조 검증**
가상머신이 심벌 참조를 직접 참조로 변환할 때 수행되며, 해당 클래스 자체를 제외한 모든 정보를 확인하는 것이다. 현재 클래스가 참조하는 특정 외부 클래스, 메서드, 필드, 그 외 자원들에 접근할 권한이 있는지 확인한다. 

### 링킹 - 준비
클래스 변수(정적 변수)를 메모리에 할당하고 초깃값을 설정하는 단계
1. 인스턴스 변수가 아닌 클래스 변수만 할당된다. 인스턴스 변수는 객체가 인스턴스화 될 때 객체와 함께 자바 힙에 할당된다.
2. 이 단계에서 클래스 변수에 할당하는 초기값은 해당 데이터 타입의 제로값이다. (참조는 null)
3. 단, ConstantValue 속성이 존재하는 경우 해당 속성의 값으로 초기화 한다. (예를 들어 final 붙인경우)

### 링킹 - 해석
JVM이 상수 풀(Constant Pool)의 심벌릭 참조(Symbolic Reference)를 직접 참조(Direct Reference)로 대체하는 과정

#### 클래스 또는 인터페이스 해석
- 심벌릭 참조를 통해 클래스 또는 인터페이스 정의를 확인하고, 해당 정의가 메모리에 로드되어 있는지 검증
- 정의가 없을 경우 클래스를 로드하는 과정을 트리거
- 상속 계층과 인터페이스 구현 관계까지 포함하여 참조를 연결

#### 필드 해석
- 클래스 또는 인터페이스의 필드에 대한 심벌릭 참조를 확인
- 필드의 이름과 타입이 유효한지 검증
- 필드가 상위 클래스나 인터페이스에 정의되어 있을 경우 계층적으로 탐색
- 확인된 필드의 메모리 주소를 직접 참조로 변환

#### 메서드 해석
- 메서드 심벌릭 참조를 확인하여 해당 메서드가 클래스 또는 인터페이스 내에 존재하는지 검증
- 메서드 오버라이딩 및 추상 메서드 구현 여부를 검토
- 다형성을 고려해 런타임에 적절한 메서드 참조로 변환

#### 인터페이스 메서드 해석
- 인터페이스에 선언된 메서드의 심벌릭 참조를 확인
- 다중 상속 구조에서 동일한 메서드가 여러 인터페이스에 선언된 경우 올바른 구현체를 찾아 연결
- 디폴트 메서드(default method)와 정적 메서드(static method)도 확인 및 연결

### 초기화
클래스와 인터페이스의 초기화 단계는 JVM에서 실행되는 최종 단계로, 클래스 변수와 정적 블록(static block)을 실행하여 클래스의 초기 상태를 설정한다.

1. **클래스 변수 초기화**  
    클래스 변수는 링킹-준비 단계에서 기본값으로 초기화되었으며, 초기화 단계에서 코드에 정의된 값으로 다시 설정된다.
    
    - `static`으로 선언된 변수들이 이 단계에서 값을 할당받는다.
2. **정적 블록 실행**  
    정적 블록은 클래스 로딩 시 한 번 실행되며, 클래스 변수의 초기화나 정적 로직 처리를 포함할 수 있다.
    
    - 정적 블록은 클래스 파일에 작성된 순서대로 실행된다.
3. **초기화 시점**  
    JVM은 클래스 또는 인터페이스가 처음으로 참조될 때 초기화를 수행한다. 다음 경우에 초기화가 트리거된다:
    
    - 클래스의 정적 필드에 접근할 때
    - 클래스의 정적 메서드를 호출할 때
    - 클래스 객체를 생성할 때 (`new` 연산자)
    - 클래스의 `Class.forName()` 호출 시
    - 정적 블록을 포함한 다른 정적 리소스 참조 시
4. **특징**
    
    - 초기화 과정은 상위 클래스의 초기화가 완료된 후 진행된다.
    - 인터페이스의 경우 정적 변수 초기화와 정적 메서드의 실행만 포함되며, 상위 인터페이스의 초기화는 필요할 때만 수행된다.
    - 초기화는 한 번만 이루어지며, JVM 프로세스에서 해당 클래스는 이후 다시 초기화되지 않는다.






