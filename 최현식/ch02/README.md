# 2장!
2장에서는 JVM이 관리하는 다양한 메모리 영역을 소개하고, 각 영역이 수행하는 역할과 관리 대상, 생길 수 있는 문제를 설명함

- C/C++ 개발자
    - 메모리 관리 측면에서 는 전권을 가진 황제인 동시에 잡다한 막노동도 직접하는 일꾼
    - 객체의 소유권 뿐만 아니라, 객체의 일생을 탄생부터 죽음까지 관리할 책임을 져야 함
- 자바 개발자
    - 가상 머신이 제공하는 자동 메모리 관리 메커니즘 혜택
    - 메모리 할당 및 해제를 짝지어 코딩하지 않아도, 메모리 누수나 오버플로 문제를 거의 겪지 않음
    - 통제권을 위임해서 발생하는 단점도 존재
    - 문제가 발생했을 때, 가상 머신의 메모리 관리 방식을 이해하지 못하면 해결이 쉽지 않음


<br/>
<br/>

# 자바 런타임 메모리 영역 
![image](https://github.com/user-attachments/assets/718c1790-ea83-486c-820b-36a86afeef82)

JVM이 자바 프로그램을 실행하는 동안 필요한 메모리 영역으로, 각 영역들은 각각의 목적과 생성/삭제 시점이 존재한다. (예를 들어 가상 머신 프로세스 시작과 동시에 생성, 사용자 스레드 시작/종료에 맞춰 시작 등)


# 프로그램 카운터 (PC)
### 소개
- 현재 실행 중인 스레드의 '바이트코드 줄 번호 표시기'로 작은 영역
- `바이트코드 인터프리터`는 이 카운터의 값을 바꿔 다음에 실행할 바이트코드 명령어를 선택
    - 프로그램의 제어 흐름, 분기, 순환, 점프 등을 표현
    - 예외 처리나 스레드 복원 같은 모든 기본 기능이 이 표시기를 통해 이루어짐
- 스레드가 생성/삭제될 때 해당 영역도 함께 생성/삭제된다.
### 특징
- JVM에서 멀티스레딩은 CPU 코어를 여러 스레드가 교대로 사용하는 방식으로 구현됨
- 특정 시각에 각 코어는 한 스레드의 명령어만 실행하게 됨
- 따라서 스레드 전환 후 이전에 실행하다 멈춘 지점을 정확하게 복원하기 위해 스레드별로 고유한 `프로그램 카운터`가 필요함
    - 해당 영역을 `스레드 프라이빗 메모리`라고 한다.
- 어떤 값이 저장되어있을까?
    - 스레드가 자바 메서드를 실행 중일 때는, 실행 중인 바이트코드 명령어의 주소가 PC에 기록
    - 스레드가 네이티브 메서드를 실행 중일 때는 PC에 Undefined(정의되지 않음)가 기록되어 있음
- PC 영역은 JVM 명세에서 유일하기 OutOfMemoryError 조건이 명시되지 않은 영역이다.


# 자바 가상 머신 스택
### 소개
- 자바 메서드(바이트코드)를 실행할 때 사용
- 스택도 `스레드 프라이빗` 영역에 해당한다.
- 스레드가 생성/삭제될 때 해당 영역도 함께 생성/삭제된다.
- 각 메서드가 호출될 때마다 JVM은 `스택 프레임`을 만든다.
    - 지역 변수 테이블, 피연산자 스택, 동적 링크, 메서드 반환값 등의 정보를 저장
    - 생성된 스택 프레임을 가상 머신 스택에 Push하고, 메서드가 끝나면 Pop한다.
### 특징
- 지역 변수 테이블
    - JVM이 컴파일타임에 알 수 있는 다양한 기본 데이터 타입, 객체 참조, 반환 주소 타입을 저장
        - 원시타입: boolean, byte, char, short, int, float, long, double
        - 반환 주소 타입: 바이트코드 명령어의 주소
    - 이 데이터 타입들을 저장하는 공간을 `지역 변수 슬롯`이라고 함
        - 일반적으로 슬롯하나의 크기는 32비트로, double형과 같이 64비트가 필요한 경우 2개의 슬롯을 사용
    - 지역 변수 테이블을 구성하는 데 필요한 데이터 공간은 `컴파일 과정에서 할당`
- 자바 메서드는 스택 프레임에서 지역 변수용으로 할당받을 크기는 `완벽하게 결정`되어있어 메서드 실행 중에 절대 변하지 않는다.
    - 정확히는 할당받은 `지역 변수 슬롯`의 갯수는 변하지 않는다. (슬롯의 크기는 JVM 구현체마다 다름)
- JVM 명세에는 스택 영역에서 두가지 오류가 정의되어있다.
    - StackOverflowError
        - 스레드가 요청한 스택 깊이가 가상 머신이 허용하는 깊이보다 클 때 발생
    - OutOfMemoryError
        - 스택 용량을 동적으로 확장할 수 있는 JVM에서, 여유 메모리가 부족해 스택을 확장하기 힘들 때 발생
        - 핫스팟 가상 머신은 스택 용량을 동적으로 늘리지 못한다.

```ad-question
title: 참조타입 vs 객체참조
참조 타입과 객체 참조는 다르다. 참조 타입은 객체의 시작 주소를 가리키는 참조 포인터일 수도 있고, 객체를 대표하는 핸들 또는 객체와 관련한 다른 위치를 가리킬 수도 있다.
```


# 네이티브 메서드 스택
### 소개
- 스택과 유사하게 동작하며, 네이티브 메서드를 실행할 때 사용
### 특징
- JVM 명세에서 네이티브 메서드 스택에서 메서드를 어떤 구조로 표현해야 하는지 아무것도 명시하지 않음
- 따라서 자유롭게 구현할 수 있다.
- 그래서 네이티브 메서드 스택과 가상 머신 스택을 하나로 합쳐 놓은 가상 머신도 있다.
    - 대표적으로 핫스팟 가상 머신이 여기에 해당
- 스택 영역과 마찬가지로 StackOverflowError, OutOfMemoryError가 발생할 수 있음


# 자바 힙
### 소개
- 유일한 목적은 '객체 인스턴스를 저장'하는 것
    - '거의' 모든 객체 인스턴스와 배열이 이 영역에 할당됨 (?) ??????????????????????
    - 자바 언어가 발전하면서 '값 타입'을 지원할 것으로 예상됨 (?)
- 자바 애플리케이션이 사용할 수 있는 가장 큰 메모리
- 자바 힙은 모든 스레드가 공유하며, 가상 머신이 구동될 때 만들어짐
### 특징
- 가비지 컬렉터가 관리하는 메모리 영역으로 `GC 힙`이라고도 불림
- JVM 명세에서 힙은 `물리적`으로는 떨어진 메모리들로 구성되어도 되지만, `논리적`으로는 연속되어야 함
    - 대다수의 가상 머신은 큰 객체(주로 배열)를 물리적으로도 연속된 메모리 공간을 사용하도록 구현함
    - 저장 효율을 높이고 구현 로직을 단순하게 유지하기 위함
- 자바 힙은 크기를 고정할 수도, 확장할 수도 있게 구현할 수 있음
    - 주류 가상 머신들은 모두 확장 가능한 형태로 구현되어있음 (-Xmx, -Xms 매개 변수 사용)
    - 힙 영역을 더 이상 확장할 수 없을 때, 새로운 인스턴스가 생성되는 경우  OutOfMemoryError 발생
### 가비지 컬렉터
- 대다수 현대적인 가비지 컬렉터는 `세대별 컬렉션 이론`을 기초로 설계
    - 신세대, 구세대, 영구 세대, 에덴 공간, 생존자 공간에서부터, 생존자 공간으로 같은 용어가 자주 등장
    - 이러한 영역 구분은 일반적인 가비지 컬렉터들의 설계일 뿐, 이 형태로 메모리를 구성해야하는 것은 아님
    - JVM 명세에는 힙 영역의 세부 구분에 관한 명시가 따로 없음
- 자바 힙 영역을 다시 작은 영역으로 구분하는 목적은 `메모리 회수와 할당을 더 빠르게` 하기 위함


# 메서드 영역
### 소개
- 가상 머신이 읽어들인 타입 정보, 상수, 정적변수, JIT 컴파일러가 컴파일한 코드 캐시 등을 저장
- 자바 힙처럼 모든 스레드가 공유하는 영역
- JVM 명세에서는 메서드 영역도 논리적으로는 힙의 한 부분으로 기술함 
### 특징
- 메서드 영역과 영구 세대는 같지 않음
    - 핫스팟 가상 머신 개발팀이 가비지 컬렉터의 수집 범위를 메서드 영역까지 확장하기로 결정했고, 따라서 영구세대에 메서드 영역을 구현햇다.
    - JDK7에서 핫스팟은 그 전까지 영구세대에서 관리하던 문자열 상수, 정적 변수 등의 정보를 자바 힙으로 옮김
    - JDK8에서 영구 세대라는 개념을 완전히 지우고, 네이티브 메모리에 메타스페이스를 구현 (https://openjdk.org/jeps/122)
- JVM 명세에서 메서드 영역은 자바 힙과 마찬가지로 연속될 필요가 없고, 크기를 고정하거나 확장해도 되며, 가비지 컬렉션의 대상이 아니여도 된다.
    - 해당 영역에서 가비지 컬렉션이 유의미한 경우가 거의 없다.
    - 메서드 영역에 한번 들어온 데이터가 영구적인 것은 아님
    - 메서드 영역에서 회수할 대상은 대부분 상수풀과 타입이라서 회수 효과가 상대적으로 매우 작다.
        - 특히 타입은 회수할 수 있는 조건이 상당히 까다롭다.
        - 하지만 썬 시절 핫스팟에서 '메서드 영역을 완벽하게 회수하지 않아 메모리 릭이 발생'한 심각한 버그가 존재했기 때문에 가비지 컬렉션을 진행해야 함
- JVM 명세에서 메서드 영역이 꽉 차 필요한 만큼 메모리를 할당할 수 없을 때 OutOfMemoryError가 발생


# 런타임 상수 풀
### 소개
- 메서드 영역의 일부
- 상수 풀 테이블에는 클래스 버전, 필드, 메서드, 인터페이스 등 클래스 파일에 포함된 설명 정보 + 컴파일 타임에 생성된 다양한 리터럴과 심벌 참조가 저장됨
- 가상 머신이 클래스를 로드할 때, 이러한 정보를 메서드 영역의 런타임 상수 풀에 저장함
### 특징
- 자바 가상 머신은 클래스 파일의 각 영역별로 엄격한 규칙을 정해놓음
    - 가상 머신이 클래스 파일을 로드해 실행하려면 각 바이트에는 명세가 요구하는 데이터가 들어있어야 함
    - 다만 런타임 상수 풀에 대해서는 JVM 명세에서 요구 사항을 상세히 정의하지 않아 자유롭게 구현 가능
    - 하지만 일반적으로 클래스 파일에 기술된 심벌 참조 및 심벌 참조로부터 번역된 직접 참조 모두 런타임 풀에 저장됨
- 클래스 파일의 상수 풀과 비교해 런타임 풀은 동적이라는 특징을 가짐
    - 자바 언어에서 상수가 꼭 컴파일타임에 생성되야 한다는 규칙이 없음
    - 런타임에도 메서드 영역의 런타임 상수 풀에 새로운 상수가 추가될 수 있음
    - 개발자들이 많이 사용하는 String.intern() 에 이러한 특성이 반영되어 있음
- 상수 풀의 공간이 부족하면 OutOfMemoryError가 발생


```ad-question
title: 심벌참조란 무엇일까?
> Symbolic Address를 생각하면 좋을 듯!


자바에서 심벌 참조(Symbol Reference)는 프로그램 내에서 변수, 메서드, 클래스 등의 이름을 참조하는 방법을 의미합니다. 심벌 참조는 주로 다음과 같은 요소를 포함합니다:

- 변수 참조: 특정 변수를 사용할 때 그 변수의 이름을 사용하여 참조합니다. 예를 들어, int x = 10;에서 x는 심벌 참조입니다.
- 메서드 참조: 특정 메서드를 호출할 때 메서드의 이름을 사용하여 참조합니다. 예를 들어, myObject.myMethod();에서 myMethod는 심벌 참조입니다.
- 클래스 참조: 클래스를 사용할 때 클래스의 이름으로 참조합니다. 예를 들어, String str = new String("Hello");에서 String은 심벌 참조입니다.

자바는 이러한 심벌을 사용하여 코드를 읽고 쓰는 데 도움을 줍니다. 심벌 참조는 컴파일러가 해당 이름을 찾아 실제 메모리 주소와 연결하는 데 중요한 역할을 합니다.

추가적으로, 자바의 리플렉션(reflection) 기능을 사용하면 런타임에 심벌 참조를 동적으로 다룰 수 있습니다. 이를 통해 클래스, 메서드, 필드 등의 정보를 프로그램 실행 중에 조회하고 조작할 수 있습니다.
```

```ad-question
title: String.intern()을 쓰지 말라고 들은 것 같은데..
```


# 다이렉트 메모리
### 소개
- 
- 가상 머신 런타임에 속하지 않으며, JVM 명세에 정의된 영역이 아님
- 하지만 자주 쓰이는 메모리이며 OutOfMemoryError의 원인이 될 수도 있어 알아둬야 함
### 특징
- 물리 메모리를 직접 할당하기 때문에 자바 힙 크기의 제약과는 무관
- 총 메모리 용량(물리메모리, 스와프 파티션, 페이징 파일 포함)과 프로세서가 다룰 수 있는 주소 공간을 넘어설 수는 없음
- 사용되는 모든 메모리 영역의 합이 물리 메모리 한계(물리적 제약 + 운영 체제 수준의 제약)를 넘어서면 동적 확장을 시도할 때 OutOfMemoryError가 발생


```ad-question
title: NIO는 무엇일까?
NIO는 네이티브 함수 라이브러리를 이용하여 힙이 아닌 메모리를 직접 할당할 수 있다. 이 메모리에 저장되어 있는 DirectByteBuffer 객체를 통해 작업을 수행할 수 있다.
따라서 자바 힙과 네이티브 힙 사이에서 데이터를 복사해 주고받지 않아도 돼서 일부 시나리오에서 성능을 크게 개선할 수 있다.
```


<br/>
<br/>


# 핫스팟 가상 머신
가장 보편적인 핫스팟 가상 머신의 Heap 메모리가 만들어지는 시기, 저장되는 상세 구조, 접근 방식 등을 다룬다. 
핫스팟이 관리하는 자바 힙에서의 객체 생성(할당), 레이아웃, 접근 방법 등 전체과정에 대한 상세내용을 소개한다.

# 객체 생성
- 언어 수준에서 객체 생성(복사와 역직렬화 제외)은 단순히 new 키워드를 쓰면 끝남
- 자바 가상 머신이 new 명령에 해당하는 바이트코드를 만나면, 이 명령의 매개 변수가 상수 풀 안의 클래스를 가리키는 심벌 참조인지 확인

- 자바 컴파일러는 new키워드를 발견하면 바이트코드 명령어인 new와 invokespecial로 변환한다. new는 앞서 이야기한 메모리 할당을 의미하며, invokespcial은 init()메소드 호출을 담당한다. (new가 아닌 다른 방식으로 객체가 생성되면 init()이 실행되지 않을 수 있다.)
- 이 과정은 아래 코드들에 모두 나와있다.
    - 핫스팟 바이트코드 인터프리터: https://github.com/openjdk/jdk/tree/master/src/hotspot/share/interpreter
    - 1999라인 참고: https://github.com/openjdk/jdk/blob/master/src/hotspot/share/interpreter/zero/bytecodeInterpreter.cpp

## JVM 레벨
### 클래스 로딩
- 해당 심벌 참조가 뜻하는 클래스가 로딩, 해석, 초기화되었는지 확인
- 준비되지 않은 클래스라면 로딩 부터 진행
- 로딩이 완료된 클래스라면 새 객체를 담을 메모리를 할당
    - 객체에 필요한 메모리 크기는 클래스를 로딩하고 나면 완벽하게 알 수 있음
    - 객체용 메모리 공간 할당은 자바 힙에서 특정 크기의 메모리 블록을 잘라주는 일

### 메모리 할당
- 가비지컬렉터가 컴팩트(모으기)를 할 수 있느냐에 따라 자바 힙이 규칙적인지 결정됨
- 자바 힙이 규칙적이라면, 포인터 밀치기(bump the pointer)를 통해 메모리를 할당
    - 규칙적? 사용 중인 메모리와 여유 메모리 영역을 완벽히 구분할 수 있는 것
    - 시리얼과 파뉴(ParNew) 가비지 컬렉터의 경우 단순하고 효율적인 해당 방식 채택
- 자바 힙은 규칙적이지 않다면 VM은 가용 메모리 블록 목록을 별도로 관리하여 메모리를 할당함
    - 규칙적이지 않음? 사용 중인 메모리와 여유 메모리가 뒤섞여 있어 포인터 밀쳐내기 사용 어려움
    - 이론상의 CMS처럼 스윕 알고리즘을 적용한 컬렉터를 쓰는 시스템이 해당 방식 사용
- 메모리 할당을 받으면 JM은 할당받은 공간을 0으로 초기화 됨
    - 객체 헤더 제외
    - 모든 필드가 자연스럽게 각 데이터 타입에 해당하는 0값으로 초기화 됨
    - 따라서 자바 코드에서 객체의 인스턴스 필드를 초기화하지 않고도 사용할 수 있음 (쓰레기값 x)

### 멀티스레드 환경 고려
멀티스레딩 환경에서 여유 메모리의 시작 포인터 위치를 단순히 수정하는 일은 ThreadSafe하지 않다. 따라서 이를 보장해주어야 한다. 

**해결방법1: 메모리 할당 동기화**
- 실제로 비교 및 교환(CAS)과 실패 시 재시도 방싱의 가상머신은 갱신을 원자적으로 수행

**해결방법2: 스레드마다 다른 메모리 공간 할당**
![image](https://github.com/user-attachments/assets/678f3ed7-ae78-4fc1-ba9b-7d3ed97ef053)

- 스레드 각각이 자바 힙 내에 작은 크기의 전용 메모리를 미리 할당
- 이러한 메모리를 TLAB(스레드 로컬 할당 버퍼)라고 함
- 각 스레드는 로컬 버퍼에서 메모리를 할당 받아 사용하다가 버퍼가 부족해지면 그 때 동기화를 해 새로운 버퍼를 할당받는 식
- 가상 머신이 스레드 로컬 할당 버퍼를 사용할지는 -XX:+/-UseTLAB 매개 변수로 설정
- TLAB 할당 시, 할당받은 공간을 0으로 초기화

### 객체에 필요한 설정
- 객체의 헤더에 정보 설정
    - 객체 헤더 설정 과정은 JVM 구동 모드(편향락 활성화 등)에 따라 달라짐
    - 어느 클래스의 인스턴스 인지, 클래스의 메타 정보는 어떻게 찾는지, 이 객체의 해시 코드는 무엇인지(정확히는 Object::hashCode()가 처음 호출될 때 계산함), GC 세대 나이는 얼마인지 등의 정보를 설정

## 자바 언어 레벨
- 해당 객체를 개발자의 의도대로 여러 자원과 상태 정보를 갱신해줘야한다.
    - 예를 들어 필드의 기본값 세팅
- new() 명령어에 이어서 < init > () 메서드까지 실행되어야 개발자의 의도대로 객체가 사용가능해진다.


# 핫스팟VM 메모리 레이아웃
![image](https://github.com/user-attachments/assets/8af70cb0-53c1-43e9-a768-c0efad8ca577)

### 객체 헤더
- 마크 워드
    - 객체 자체의 런타임 데이터
    - 해시 코드, GC 세대 나이, 락 상태 플래그, 스레드가 점유하고 있는 락들, 편향된 스레드 아이디, 편향된 시각의 타임스탬프 등
    - 참조 압축 기능을 켜지 않았을 때, 32비트/64비트 가상머신에서 각각 32/64비트를 차지함
- 클래스(klass) 워드
    - 객체의 클래스 관련 메타데이터를 가리키는 클래스 포인터 저장
    - 해당 포인터를 통해 특정 객체가 어느 클래스의 인스턴스인지 런타임에 파악
- 배열 길이
    - 배열의 경우 배열 길이도 객체 헤더에 저장
    - 메타데이터에서는 원소의 타입을 얻고, 이곳에서 배열길이를 얻어 배열 객체가 차지하는 메모리 크기를 제대로 알 수 있음

```ad-question
title: klass
자바 가상 머신이 런타임에 자바 클래스를 다루는 데 필요한 각종 정보(정의된 필드와 메서드 등)가 담겨있는 데이터 구조를 말한다. 이 데이터는 JDK7까지는 영구 세대에, JDK8부터는 메타스페이스에 저장된다.
```

### 인스턴스 헤더
객체가 실제로 담고 있는 정보로, 프로그램 코드에서 정의한 다양한 타입의 필드 관련 내용, 부모 클래스 유무, 부모 클래스에서 정의한 모든 필드가 이 부분에 기록된다.
- 정보의 저장 순서는 가상 머신의 할당 전략 매개 변수와 자바 소스 코드에서 필드를 정의한 순서에 따라 달라짐
- 핫스팟 가상 머신은 기본적으로 long double, int, short char, byte boolean 일반 객체 포인터 순으로 할당함
- 기본 할당 전략에서 길이가 같은 필드들은 항상 같이 할당되고 저장됨
- 필드 길이가 같다면 부모 클래스에서 정의된 필드가 자식 클래스의 필드보다 앞에 배치됨
- 메모리 공간 절약을 위해 +XX:CompactFields 매개 변수를 true(기본값)으로 설정하면 하위 클래스의 필드 중 길이가 짧은 것들을 상위 클래스의 변수 사이사이에 끼워넣음

### 정렬 패딩
특별한 의미 없이 자리를 확보하는 역할로 존재하지 않을 수도 있다.
- 핫스팟 가상 머신에의 자동 메모리 관리 시스템에서 객체의 시작 주소는 반드시 8바이트의 정수배여야 하기 때문에 패딩을 채운다.


# 객체에 접근하기
대다수의 객체는 다른 객체 여러 개를 참조하여 만들어진다. JVM마다 객체 내 참조 객체에 접근하는 방법이 다르며, 주로 핸들이나 다이렉트 포인터를 사용한다.

객체에 접근하는 방식은 명세에서 구현을 정하지 않았기 때문에, 가상 머신에서 자유롭게 구현할 수 있으며 주로 핸들이나 다이렉트 포인터를 사용해 구현한다.

### 핸들
자바 힙에 핸들 저장용 풀이 별도로 존재하여, 객체의 핸들 주소가 저장된다. 각 핸들은 다시 해당 객체의 인스턴스 데이터, 타입 데이터, 구조 등 정확한 주소 정보가 담기는 방식이다.
- 장점: 안정적인 핸들의 주소가 저장된다. 가비지 컬렉션 과정에서 객체가 이동하는 일이 흔하다. 핸들을 이용하면 이렇게 객체의 위치가 바뀌는 상황에서도 참조 자체를 손대는 것이 아닌 핸들 내의 인스턴스 데이터 포인터만 변경하면 된다.
![image](https://github.com/user-attachments/assets/6c70697e-73cc-4c0b-acd4-34a7643965a1)


### 다이렉트 포인터
자바 힙에 위치한 객체에서 인스턴스 데이터뿐 아니라 타입 데이터에 접근하는 길도 제공한다. 스택의 참조에서는 객체의 실제 주소가 바로 저장되어있다. 
- 가장 큰 장점은 속도로, 핸들을 경유하는 오버헤드가 없어 빠르다.
- 핫스팟VM은 주로 다이렉트 포인터 방식을 이용한다. 
![image](https://github.com/user-attachments/assets/82cc2951-0c6a-429c-abff-6e889c602af7)


