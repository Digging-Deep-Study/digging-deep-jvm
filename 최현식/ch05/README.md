설계와 개발 단계에서의 고민을 다루기보다는, 기존 하드웨어와 소프트웨어를 유지한 채 배포와 설정 전략을 조율하여 문제를 해결하는 방법을 다룬다.
![[Pasted image 20241222014854.png]]
![image](https://github.com/user-attachments/assets/d418d4f9-f90e-493c-b8ab-6904dac96e23)



## ✅ 대용량 메모리 기기 대상 배포 전략
일반적인 OLTP 서버에서, 응답성 개선을 위해 64비트 환경과 12GB의 메모리를 준비하였으나 더 느려진 상황

### 대상환경
- 컴퓨터의 모든 자원을 웹서버가 모두 사용함
- 64비트 JDK5로 구동
- -Xmx, -Xms를 12GB로 설정
- 핫스팟 가상 머신을 서버 모드로 실행
- 페러렐 컬렉터(페러렐 스캐빈지+패러렐 올드)를 통해 메모리 관리

### 문제상황
- 웹 사이트가 장시간 응답하지 않는 일이 자주 벌어짐
- **GC 작업으로 인해 '스탑 더 월드'가 발생**하는 것이 원인
- 페러렐 컬렉터는 처리량을 더 중요하게 생각하기 때문에 **12GB의 메모리에 대해 GC 작업**을 할 때, 10초이상의 '스탑 더 월드'가 발생
- 사용자가 웹페이지를 요청하면 해당 파일이 메모리에 올라가게 됨 → 객체가 거대하기 때문에 바로 '구세대'에 위치하게 됨 (힙 메모리 금방 터짐)

### 해결방법1: 힙 메모리 크기 줄이기
- 힙 메모리의 크기를 줄이면 자연스럽게 '스탑 더 월드'시간도 줄어들게 된다. (안좋은 방법)

### 해결방법2: 단일 인스턴스와 12GB 메모리 유지
- 가비지 컬렉터를 '지연 시간 통제'를 목표로하는 것으로 교체하기
	- 예를 들어 셰넌도어, ZGC가 해당함
	- 가상 머신 인스턴스 하나가 거대한 자바 힙 메모리를 관리할 때 유리 (현재상황과 동일하게)
- 가비지 컬렉터를 '페러렐 컬렉터'로 유지하기
	- GC 없이 하루 이상 가동될 수 있을만큼 넉넉한 메모리와 최적화된 환경을 준비한다.
	- 사용자가 없는 시간에 (예를 들어 새벽) 정기적으로 GC를 수행하는 방법
	- 세션이나 전역 수준으로 생존하는 객체를 최대한 줄여 Full-GC가 발생하는 것을 방지해야 함

```ad-tip
title: 많은 메모리와 함께 JVM 사용할 때 팁
- G1 컬렉터와 '점진적 회복'이 활용되며 힙 메모리의 거대블록을 수거하느라 발생하는 긴 일시정지는 많이 줄어들었따.
- 대규모 단일 애플리케이션은 문제 상황에서 힙덤프를 만드는 것도 쉽지 않기 때문에 (메모리 용량만큼 힙덤프 파일을 만들어야하기 때문에) 운영도구를 잘 활용해야한다. 
- 64비트 JVM은 대용량 메모리를 사용할 수 있는 반면, 성능은 32비트보다 약간 느리다. (압축포인터, 프로세서 캐시 라인 용량 등의 요인)
- 64비트 JVM은 32비트 JVM보다 더 많은 메모리가 필요하다. (포인터 확장, 데이터 타입 정렬, 패딩 등의 요인)
```

### 해결방법3: 가상 머신 여러개를 동시에 띄워 논리적인 클러스터 구성
단일 어플리케이션 활용시에 고려해야하는 문제들을 신경쓰지않고, 하드웨어 자원을 최대한 끌어쓰기 위해 물리머신 한대에 논리적으로 클러스터를 구성해 사용하는 방식
![[Pasted image 20241222005735.png]]
![image](https://github.com/user-attachments/assets/c2c5dc53-047a-4cb4-8d1e-225a6de3dc7d)

단순히 하드웨어 자원을 최대한 활용하는 것이 관심사 이기 때문에, 클러스터 환경을 개발단계에서 크게 고려할 필요가 없음 (?? 상관있지 않나)

단점
- 각 노드들이 전역 자원을 놓고 경합한다. 예를 들어 디스크가 있다. 동시 쓰기에서 문제가 발생할 가능성이 크다.
- ConnectionPool 등을 효율적으로 활용하기 어렵다.
- HashMap 등의 로컬캐시를 많이 이용하는 경우, 각 노드마다 독립된 캐시를 가지기 때문에 비효율적이다.





## ✅ 클러스터 간 동기화로 인한 메모리 오버플로
브라우저-서버 기반 경영 정보 시스템

### 대상환경
- HP미니컴퓨터 2대 (2 CPU, 8GB 메모리) 
- 미들웨어인 웹로직 9.2를 3개씩 구동하여 총 6노드의 선호도 클러스터를 구성
	- 각 노드 사이에 세션 동기화는 일어나지 않음
	- 하지만 일부 데이터를 공유해야만 함
- 공유 데이터 관리 방식
	- 초기: 데이터베이스를 통해 관리 → 읽기/쓰기가 잦고 경합이 치열함
	- 후기: 글로벌캐시(JBossCache) 구축
	- 시간이 지나며 메모리 오버플로가 가끔씩 발생하게 됨

### 문제상황
- -XX:+HeapDumpOnOutOfMemoryError 매개 변수를 추가하여 서비스를 운영하여 원인 파악 진행
- 오버플로가 발생한 힙덤프에서 org.jgroups.protocols.pbcast.NAKACK 객체가 무수히 발견됨
- 실패시 재전송을 위해 GMS에 등록된 모든 노드가 데이터를 제대로 수신했는지 확인할 때 까지 메모리에 발송 내역을 보관
- 글로벌 보안 필터에서도 '접속 시간' 동기화를 위해 이를 활용하고 있었고, 때문에 사용자가 요청을 보낼때마다 이게 갱신되어버리고 있었던 것!
- 특정 상황에서 네트워크가 데이터 전송량을 다 처리하지 못하게 되면, 재전송을 위한 데이터가 메모리에 계속 쌓이다가 오버플로를 일으킴

```ad-question
title: JBossCache?
과거에 널리 사용되던 Java 기반의 **분산 캐시(Distributed Cache)** 기술로, 데이터를 메모리에 저장해 애플리케이션의 성능을 향상시키는 데 사용
- 현재는 후속 프로젝트인 Infinispan으로 대체되었으며, 하이버네이트 2차 캐시나 분산 세션 관리용으로 활용되는 것이 일반적
- 대체 가능 기술로는 Redis, Memcached 등이 있음
```





## ✅ 힙 메모리 부족으로 인한 오버플로 오류
학교의 소규모 프로젝트 사례. 브라우저-서버 기반 온라인 시험 시스템

### 대상환경
- 서버-푸시 기술을 활용해 클라이언트가 서버로부터 시험데이터를 실시간으로 받아 볼 수 있음.
- 서버-푸시 프레임워크로는 CometD 1.1.1, Jetty 7.1.4 활용
- 물리머신: 인텔 i5, 4GB 메모리, 32비트 윈도우

### 문제상황
- 테스트 중 서버에서 메모리 오버플로가 가끔 발생
- 시스템이 한번만 비정상 종료되어도 온라인 시험 전체가 중단될 위험이 있음
- 힙 메모리를 최대한 늘려도(32비트 기준 1.6GB) 오버플로는 여전히 발생
	- 여유 메모리가 부족하여 힙덤프 생성도 못함
- jstat를 통해 확인해보니 GC가 자주일어나지않았으며, 모든 메모리 영역이 안정적임
- 현재 사용되는 프레임워크는 NIO 연산을 매우 많이 수행함 → JVM 메모리 뿐만 아니라 물리머신 자체의 자원이 부족해져서 문제가 발생할 수 있음

- 오버플로시 살펴봐야할 영역들
	- 다이렉트 메모리
	- 스레드 스택 (가상 머신 허용치를 넘기는 깊이의 스택 요구시)
	- 소켓 버퍼 영역 (IOException: Too many open files) 
	- JNI 코드 (네이티브 라이브러리는 JVM의 네이티브 메서드 스택 및 메모리를 활용)
	- JVM과 GC가 차지하는 메모리 크기





## ✅ 시스템을 느려지게 하는 외부 명령어
자바에서 외부 명령을 자주 호출하는 경우 주의할 것, 자바 API로 처리 가능하다면 자바로 처리하자!
![[Pasted image 20241222094044.png]]
![image](https://github.com/user-attachments/assets/0dc78f8d-9145-4bc1-b4f9-296c0544593d)

예를 들어 아래처럼 외부 프로세스를 생성/종료를 반복하는 경우 메모리 부담이 커지게 된다.
1. 자바에서 쉘 스크립트 호출
2. 새로운 쉘 스크립트 프로세스가 생성되어 작업을 수행
3. 쉘 스크립트 프로세스 종료





## ✅ 서버 가상 머신 프로세스 비정상 종료
외부 시스템을 통해 동기화 작업이 필요한 서비스에서, 응답 속도를 위하여 해당 작업을 비동기로 수행
→ 외부 시스템에 상태가 안좋아서 응답이 지연되었고, 그 결과 제때 응답을 받지못한 쓰레드와 소켓이 쌓이면서 JVM이 버티지 못하고 사망함
→ 비동기 소켓호출에서 MessageQueue 방식으로 변경하여 해결!





## ✅ 부적절한 데이터 구조로 인한 메모리 과소비
64비트 백그라운드 RPC 서버 사례

### 문제상황
- 평소에는 Minor-GC 시간이 30ms 이내로 수행됨
- 하지만 데이터 분석을 위해 10분 단위로 80MB 크기의 파일을 읽게되며, 100만개 이상의 HashMap<Long, Long>이 생성되어 Minor-GC에 500ms 이상이 소요됨

### 해결방법
- HashMap은 현재 로직에 적합하지 않다. 
- HashMap<Long, Long>의 구조
	- 24바이트
		- Long 객체는 8바이트의 마크워드, 8바이트의 클래스 포인터, 데이터를 담기위한 실제 8바이트의 long 공간으로 구성
	- 32바이트
		- Long 객체는 Map.Entry에 저장되며, Map.Entry는 16바이트의 객체 헤더, 8바이트의 next 필드, 4바이트의 해시 필드,,, 마지막으로 패딩 4바이트
	- 8바이트
		- HashMap에서는 8바이트 참조를 통해 Entry를 가리킴
- 총 88바이트의 공간을 Long, Long을 기억하기 위해 활용하게 됨
- 각 자료구조의 메모리 할당을 확인하여, 현재 상황에 맞는것을 적절히 선택하여 활용하자!


<br/>

# 인텔리제이 빠르게 사용하기


## JDK 버전 업그레이드에 따른 성능 변화
이클립스 구동시간을 10%정도 단축한 효과!
![[Pasted image 20241222015231.png]]![image](https://github.com/user-attachments/assets/6212c164-963d-4c74-9fa5-5d9f15fbbc70)

Link: https://www.google.com/url?sa=i&url=https%3A%2F%2Fkstefanj.github.io%2F2021%2F11%2F24%2Fgc-progress-8-17.html&psig=AOvVaw2TfhSMdKSBVRHd10BITm3K&ust=1734886344673000&source=images&cd=vfe&opi=89978449&ved=0CBgQ3YkBahcKEwiw5Jm0qbmKAxUAAAAAHQAAAAAQBA


그렇지만 인텔리제이는 자체 내장된 JVM을 사용하는 듯하다.
![[Pasted image 20241222015546.png]]![image](https://github.com/user-attachments/assets/0f9107ca-0005-4bbf-8a80-a8d4a161b11f)


이것도 바꿀수가 있다.
![[Pasted image 20241222015955.png]]
![[Pasted image 20241222020007.png]]
![image](https://github.com/user-attachments/assets/7c47772b-480b-44fc-9e9e-6c5ac7f89ad1)
![image](https://github.com/user-attachments/assets/62089621-0d2b-4576-9e6f-8a18499dda1f)

`vanilla` JBR 을 사용하면 메모리 누수 문제가 잡힌다는 이야기가 있다! 

JRE 변경 출처: https://jojoldu.tistory.com/800


## 인텔리제이 JFlag 설정
```sh
# 일반설정
-server : JVM이 서버 최적화된 HotSpot 컴파일러를 사용
-Xms4096m : 초기 힙 크기
-Xmx4096m : 최대 힙 크기

# 메모리 관리
-XX:NewRatio=3
-Xss16m : 각 스레드의 스택 크기

#성능 최적화
-XX:+AlwaysPreTouch : 런타임 중 메모리 할당에 소요되는 시간을 줄여 성능을 향상
-XX:+TieredCompilation : JVM은 자주 사용되는 메서드를 여러 번 컴파일하여 성능 향상, 실행 속도 향상
-XX:ReservedCodeCacheSize=512m : 예약된 코드 캐시 크기
-XX:SoftRefLRUPolicyMSPerMB=50 : SoftReference Least Recently Used(LRU) 정책을 조정
-XX:+UseCodeCacheFlushing : 메모리가 부족할 때 코드 캐시를 지워 특정 시나리오에서 성능을 향상

#시스템/어플리케이션 속성
-Dsun.io.useCanonCaches=false-ea : 파일 경로에 대한 정규화 캐시 사용을 비활성화하여 특정 환경에서 성능을 향상
-XX:CICompilerCount=4 : 백그라운드 컴파일 스레드 수
-Dsun.io.useCanonPrefixCache=false : 정규화를 위한 접두사 캐시 사용을 비활성화하여 특정 조건에서 성능을 향상
-XX:+HeapDumpOnOutOfMemoryError : OutOfMemoryError가 발생할 때 힙 덤프 파일을 생성하여 메모리 관련 문제 해결에 도움
-XX:-OmitStackTraceInFastThrow : 빠른 throw에서도 예외 메시지에 스택 추적을 포함
-Djdk.attach.allowAttachSelf=true : 디버깅 목적으로 JVM이 자체에 연결
-Dkotlinx.coroutines.debug=off : 프로덕션 환경에서 오버헤드를 줄이기 위해 Kotlin 코루틴에 대한 디버깅을 비활성화
-Djdk.module.illegalAccess.silent=true : 특정 타사 라이브러리에서 발생할 수 있는 불법 모듈 접근에 대한 경고를 표시하지 않음
-Dfile.encoding=UTF-8 : 기본 파일 인코딩
-XX:+UseG1GC : 메모리 사용 패턴이 변동하는 IDE와 같은 애플리케이션에 더 적합한 G1(Garbage-First) 가비지 컬렉터를 사용
```
출처: [https://jong-bae.tistory.com/82](https://jong-bae.tistory.com/82) [기록하는 프로그래머:티스토리]


## 플러그인 조심하기~
코파일럿, 소나린트 등 플러그인 중에 메모리 도둑질하는 애들이 좀 있으니 조심!!



