# ☕ 자바 개요

## 자바 기술 시스템
- 자바는 프로그래밍 언어뿐 아니라 여러가지 소프트웨어와 명세로 구성된 기술 시스템을 통칭합니다.
- 일반적으로 JVM 위에서 동작하는 코틀린, 클로저, JRuby, 그루비 등도 자바 기술 시스템에 속합니다.
- 자바 기술 시스템은 크로스 플랫폼 소프트웨어를 개발하고 배포하는데 필요한 모든 것을 제공합니다.
- 자바 가상 머신은 380억 개 이상 구동 중입니다. [자바 가상 머신 비디오](https://www.youtube.com/watch?v=p_LAT12Yu6k)

### 예시
- 자바 프로그래밍 언어
- (다양한 하드웨어 플랫폼용) 자바 가상 머신 구현
- 클래스 파일 포맷
- 자바 클래스 라이브러리 API (표준 API)
- 다른 기업과 오픈 소스 커뮤니티에서 제공하는 서드 파티 클래스 라이브러리

## 자바의 대표적인 특징
- 하드웨어 플랫폼 종속을 제거하여 "한 번 작성하면 어디서든 실행된다"라는 이상을 실현합니다. (WORE)
- 상당히 안전한 메모리 관리 시스템을 갖추고 있어, 메모리 누수 문제와 엉뚱한 메모리를 가리키는 문제 대부분을 피할 수 있습니다.
- 런타임에 핫코드(빈번하게 실행되어 전체 성능에 영향을 주는 코드)를 감지, 컴파일하고 최적화하여 자바 애플리케이션이 최상의 성능을 내도록 돕습니다.
- 표준 API가 풍부하고, 다양한 기능의 서드 파티 라이브러리를 활용할 수 있습니다.

<br/>

# 🛠️ JRE vs JDK
![image](https://github.com/user-attachments/assets/16c57567-9714-4536-a49b-65be52d39705)

## JRE
- JRE는 자바 프로그램을 실행할 수 있는 표준 환경을 제공합니다.
- 자바 SE API와 자바 가상 머신, 배포 기술까지를 묶어 JRE라고 합니다.

## JDK
- 자바 프로그래밍 언어, 자바 가상 머신, 자바 클래스 라이브러리의 묶음으로, 자바 프로그램 개발에 필요한 최소한의 환경입니다.

<br/>

# 🏛️ 자바의 역사
![image](https://github.com/user-attachments/assets/406f68d3-f8c9-440e-ba86-53024e8745da)

- **JDK 1.0**: Java의 첫 번째 버전, 기본적인 언어 기능과 AWT GUI 라이브러리 포함.
- **JDK 1.1**: 이벤트 모델 개선, JDBC 지원 추가, RMI 도입.
- **JDK 1.2**: Collections 프레임워크 도입, Swing GUI 라이브러리 추가.
- **JDK 1.3**: 성능 향상, Java Sound API 추가, JNDI 지원.
- **JDK 1.4**: 정규 표현식 지원, NIO 도입, XML 지원 강화.
- **JDK 1.5 (Java 5)**: 제너릭, 애노테이션, 열거형, 포맷팅 등 언어 개선.
- **JDK 1.6 (Java 6)**: 스크립팅 API 추가, 성능 개선, 웹 서비스 지원 강화.
- **JDK 1.7 (Java 7)**: 다이아몬드 연산자, try-with-resources 구문 도입, NIO.2 API 개선.
- **JDK 1.8 (Java 8)**: 람다 표현식, Stream API 도입, 새로운 날짜/시간 API.
- **JDK 9**: 모듈 시스템 도입, JShell 도구 추가.
- **JDK 10**: 지역 변수 타입 추론(var) 도입, 가비지 컬렉터 개선.
- **JDK 11**: 장기 지원 버전, 새로운 HTTP 클라이언트 API 도입, 불필요한 기능 제거.
- **JDK 12**: Switch 표현식(프리뷰), 가비지 컬렉션 성능 개선.
- **JDK 13**: 텍스트 블록(프리뷰) 도입.
- **JDK 14**: 레코드(프리뷰), NullPointerException 메시지 개선.
- **JDK 15**: Sealed 클래스(프리뷰) 도입, 메모리 세이빙 기능 개선.
- **JDK 16**: JEP 338, 날짜/시간 API 개선.
- **JDK 17**: 장기 지원 버전, 패턴 매칭(프리뷰) 도입.
- **JDK 18**: 새로운 HTTP Client API 개선, 성능 향상.
- **JDK 19**: 패턴 매칭을 통한 switch문(프리뷰) 도입.
- **JDK 20**: 나선형 언어 기능(프리뷰) 도입, 새로운 API 개선.
- **JDK 21**: 장기 지원 버전, 가상 스레드 지원, 새로운 언어 기능 및 API 개선.
- **JDK 23**: 성능 개선, 새로운 언어 기능 및 API, 도구의 발전.

<br/>

# 🎰 JVM 종류
![image](https://github.com/user-attachments/assets/17f0ddda-568c-486d-94b5-ce5b909fe9c6)

Fig. https://catch-me-java.tistory.com/11?category=438116

## 썬 클래식 VM
- 세계 최초의 상용 자바 가상 머신.
- 자바 코드를 순전히 인터프리터 방식으로 실행.
- JIT 컴파일러 플러그인을 추가하면 더 이상 인터프리터는 동작하지 않음.
- 컴파일러를 사용하면 실행 빈도 등 컴파일에 따른 득실과 상관없이 '코드 전체'를 컴파일.
- '자바 언어는 느리다'는 인상이 생김.
- JDK 1.2까지 기본적으로 사용된 VM.

## 핫스팟 VM
- 이그젝트VM과 동일하게 '정확한 메모리 관리' 기술을 기초로 하는 핫스팟(핫 코드 감지)이 도입됨.
- 컴파일했을 때, 효과를 가장 크게 볼 수 있는 코드 영역을 런타임에 알아내어 JIT 컴파일러에 통보.
- JIT 컴파일러는 해당 코드를 메서드 단위로 컴파일.
- 메서드가 자주 호출되거나 메서드 안에 시간을 많이 잡아먹는 순환문은 JIT 컴파일을 통해 스택으로 치환됨.
- 런타임에 스택을 치환하는 기술을 온스택치환(OSR)이라고 함.
- JIT 컴파일을 빨리 끝내야 한다는 압박이 줄어 복잡한 최적화 기법을 도입할 수 있게 됨.
- 오라클 JDK에서 기본적으로 채택하여 가장 널리 쓰이는 JVM.

## IBM J9 VM (테무린)
- 핫스팟과 함께 '세계 3대 상용 JVM'이라고 불리며 독자적으로 개발됨.
- 세계에서 가장 빠른 자바 가상 머신이라는 슬로건을 기반으로 홍보.
- 임베디드, 데스크톱, 서버 애플리케이션을 모두 지원하는 다용도 가상 머신.
- 여전히 현역으로 활동 중이며 핫스팟보다 역할별로 모듈화가 잘 이루어짐.
- 가비지 컬렉터, JIT 컴파일러, 진단 모니터 등 핵심 구성요소들이 잘 추상화, 캡슐화 되어 있음.
- 오픈소스로 전환한 이후 이클립스 재단에 기부됨.
- OpenJDK 라이브러리들에 OpenJ9를 결합한 '이클립스 테무린'을 통해 사용 가능.

<br/>

# 🤖 NativeCode

- 애플리케이션 아키텍처는 거대한 단일 아키텍처에서 작은 마이크로서비스 아키텍처로 옮겨가고 있는 추세입니다.
  
## 기존 자바 개발의 문제점
- HelloWorld를 실행하려 해도 100MB가 넘는 JRE가 필요.
- 마이크로서비스에서 요구하는 특성을 만족하지 못함.
- 마이크로서비스 아키텍처에서는 분할된 서비스 각각이 수십에서 수백 GB의 메모리를 쓸 일이 없음.
- 자바는 Startup Time이 길고 최고 성능을 내기까지 예열이 필요합니다.

## 서버리스 아키텍처에서의 모순
- 함수는 서비스보다 크기가 작고 실행시간이 짧습니다.
- AWS 람다는 함수 실행 시간을 최장 15분까지 허용합니다.

## 그동안의 노력
- 최근 JDK에서는 애플리케이션 클래스 데이터 공유(AppCDS)로 로딩한 클래스 정보를 캐시해두어 다음번 구동 시간을 줄이는 기술이 도입됨.
- 자바 표준 라이브러리뿐만 아니라 사용자 코드까지 지원함.
- 노옵(no-op) 가비지 컬렉터인 앱실론 등의 기술이 도입되었음.
- 메모리를 할당만 해 줄 뿐 회수는 하지 않는 컬렉터로, 간단한 작업을 빠르게 처리한 후 즉시 종료하는 애플리케이션에 적합합니다.

## AOT 컴파일
- 애플리케이션을 실행하기 전에 네이티브 코드로 컴파일 해두는 컴파일러입니다.
- JVM은 애플리케이션을 우선 실행한 후 JIT 컴파일러를 통해 네이티브 코드로 바꿉니다.
- 컴파일을 미리 해 두면 예열 과정을 건너뛰고 처음부터 네이티브 코드를 실행할 수 있습니다.
- 런타임에 최적화하는 방식이 아니기 때문에, 시간 압박 없이 프로그램 전체를 완벽하게 분석할 수 있음.
- 이로 인해 자바는 '시작이 느리다'라는 문제를 해결할 수 있습니다.
- 단, 컴파일 타임에 모든 정보를 알아야 한다는 단점이 존재합니다 (동적 링크 불가능).

## 차세대 JIT 컴파일러
- 핫스팟 가상 머신은 기본적으로 JIT 컴파일러를 두 개 내장하고 있음.
  - **C1 컴파일러**: 컴파일 속도가 빠르지만 최적화를 적게 하는 클라이언트 컴파일러.
  - **C2 컴파일러**: 컴파일 속도는 느리지만 더 많은 최적화를 적용하는 서버 컴파일러.

- 인터프리터 또한 컴파일러로 포함할 수 있음.  
- JDK 10부터 Graal 컴파일러가 추가됨.  
- C2 컴파일러를 대체할 목적으로 핫스팟에 도입됨.  
- C2와 동일하게 고수준 중간 표현(HIR)을 사용하여 C2의 이점을 수용하기 쉬움.  
- 컴파일된 코드의 출력 품질을 더 좋게 유지하면서 개발 효율과 확장성 측면에서도 더 유리함.  
- JDK 16부터는 개발과 관리 효율을 높이고자 Graal 컴파일러를 JDK에서 GraalVM으로 독립시킴.  
- 현재는 GraalVM 기술 중 JIT 컴파일러와 네이티브 이미지를 OpenJDK에 우선 반영함.  
- JVMCI를 통해 Graal 컴파일러가 핫스팟에 이식됨.  
- **JVMCI**: JDK 9에서 '가상 머신 외부에서 자바 언어로 구현한 컴파일러를 통합할 수 있는 컴파일러 인터페이스'입니다.
- JVMCI를 통해 가상 머신 외부에서 JIT 컴파일러를 추가하거나 교체할 수 있게 됨.  
- 핫스팟 코드를 침범하지 않고도 핫스팟 가상 머신의 고유 기능을 확장하거나 수정할 수 있음.

<br/>

# 💽 Graal VM
![image](https://github.com/user-attachments/assets/f1fd3745-e3fe-4309-a7fb-36ceea8a7520)

GraalVM은 '어디서든 더 빠르게 실행된다'라는 슬로건으로, 자바의 '한 번 작성하면 어디서든 실행된다'와 대비되는 다국어 지원 플랫폼입니다. 이를 통해 자바, 코틀린, 스칼라, 그루비 등과 같은 JVM 언어는 물론, C, C++, Rust 같은 LLVM 기반 언어까지 지원하며, JavaScript, Ruby, Python, R 등 다양한 프로그래밍 언어와의 혼합 사용이 가능합니다.

## 특징
- **Cross-Language 지원**: 서로 다른 언어들이 동일한 메모리 공간에서 데이터를 주고받을 수 있음.
- **네이티브 라이브러리 사용 가능**: 기존 네이티브 라이브러리들을 추가 비용 없이 활용 가능.
- **자바 SE 호환**: 핫스팟 기반으로 탄생, 자바 가상 머신으로 활용 가능.
- **성능 최적화**: 입력된 중간 표현을 자동으로 최적화하고 JIT 컴파일을 통해 성능 향상.

## 동작 방식
- **중간 표현(IR)으로 변환**: 다양한 소스코드나 중간 형식을 GraalVM이 해석할 수 있는 IR로 변환.
- **트러플 프레임워크**: 서로 다른 언어에 대한 인터프리터를 빠르게 제작할 수 있는 언어 구현 프레임워크 제공.
- **수롱(Sulong)**: 고성능 LLVM 비트코드 인터프리터로, GraalVM과 함께 사용됨.

## 고수준 언어 가상 머신
- GraalVM은 '물리 머신에 대응하는 고수준 언어 가상 머신'입니다.
- 물리 머신의 명령어 집합과 같은 역할을 하지만 특정 고수준 언어의 특성과는 관련이 없습니다.
- 프로그래밍 언어마다 런타임 환경 성능이 달라 차이가 발생합니다.
- GraalVM은 입력된 중간 표현을 자동으로 최적화하고 런타임에 JIT 컴파일까지 해주기 때문에 네이티브 컴파일러보다 빠를 수 있습니다.
- 예를 들어 V8 기반의 자바스크립트, CPython, 루비 MRI, R 언어보다 빠른 성능을 보일 수 있음.
- 핫스팟 VM과 비교할 때, 실행 효율과 컴파일 품질 모두 표준 핫스팟보다 나은 것으로 평가됨.

- [르네상스 스위트](https://renaissance.dev)

<br/>

# 🍃 Native Image
- GraalVM은 서브스트레이트 VM과 사용자 프로그램을 하나로 묶어 네이티브 이미지를 생성합니다. 
- 이때 포인터 분석 기술을 활용하여 사용자 프로그램으로부터 도달 가능한 코드만 추려 네이티브 이미지에 담습니다. 
- 이 과정에서 초기화까지 수행하여, 최종 실행 파일이 생성되면 초기화된 힙 스냅숏을 저장해 둡니다. 
- 이를 통해 초기화 과정을 건너뛰고 프로그램을 바로 실행하여 StartUp Time을 획기적으로 줄일 수 있습니다. 
- 컴파일러가 찾을 수 없는 코드나 클래스 라이브러리를 동적으로 읽을 수 없으므로 주의해야 합니다.

## 서브스트레이트 VM
- 사전 컴파일된 네이티브 코드를 핫스팟 가상 머신 없이 실행하는 기술입니다.
- 독자적인 예외 처리, 스레드 관리, 메모리 관리, JNI 접근 메커니즘 등을 갖춘 극히 작은 런타임 환경입니다.

<br/>

## Native Image 성능 비교
### **상대적으로 빠른 시작 시간**
![image](https://github.com/user-attachments/assets/ecc6661d-97fa-4cb6-8a70-a6d28bcd6a1e)
기존 자바 마이크로서비스의 시작 시간이 900ms ~ 2000ms인 것에 반해 GraalVM 네이티브 이미지는 16ms ~ 40ms 수준입니다.

### **상대적으로 작은 메모리 사용량**:
![image](https://github.com/user-attachments/assets/8b058e58-d1ad-47c2-b89a-28b153652dd5)
핫스팟 가상 머신은 그 자체로 수십 MB의 메모리를 사용합니다.  
기존 자바 마이크로서비스 메모리 사용량이 100MB ~ 200MB인 것에 반해 GraalVM 네이티브 이미지는 17MB ~ 40MB 수준입니다.

### Spring Petclinic 예제
![image](https://github.com/user-attachments/assets/1cc4d20e-b4b0-4276-b1c1-934499e357aa)

### 자바스크립트와 GraalVM
- 서브스트레이트 VM을 통해 자바스크립트를 실행하면 4.2MB의 메모리가 사용됩니다.
- 기존 Node.js(V8)으로는 20MB의 메모리가 사용됩니다.

### 기존 OLTP 서비스에 적용해보는 중!!
![image](https://github.com/user-attachments/assets/9f4ec5f8-a84d-4bc6-a56c-f62a8de42e6f)
- [문제 링크](https://github.com/SWM-TEAM-SSH/dart-server/issues/216)
