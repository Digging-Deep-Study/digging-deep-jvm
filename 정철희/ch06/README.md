# 클래스 파일 구조

## 플래폼 독립을 향한 초석

완전 튜링이란 컴퓨터가 튜링 기계의 능력을 가지고 있다는 것을 의미한다.  
즉, 운영 체제나 하드웨어에 상관없이 동일한 프로그램을 실행할 수 있다.  
이러한 플랫폼 독립성을 가지기 위해 Java는 바이트 코드를 사용한다.  
바이트 코드는 플랫폼에 독립적이기 때문에 어떤 플랫폼에서도 실행이 가능하다.  
바이트 코드는 JVM이라는 가상 머신에서 실행된다.

## 클래스 파일의 구조

클래스 파일의 구조는 Java 초기 구조와 크게 변하지 않았다.  
모든 클래스 파일은 하나의 클래스 혹은 인터페이스를 정의한다.  
그런데 클래스나 인터페이스가 꼭 파일에 담아둘 필요는 없고 클래스 파일 형식만 지키면 된다.  
즉, 디스크에 파일 형태로 저장되어 있을 필요는 없다는 것이다.  
클래스 파일은 바이트를 하나의 단위로 하는 이진 스트림 집합체이다.  
그리고 `부호가 없는 숫자`와 `테이블`이라는 타입으로 구성되어 있다.

### 부호가 없는 숫자

기본 데이터 타입을 나타내는데 사용된다.  
숫자, 인덱스 참조 값, 수량을 기술하거나 UTF-8 문자열을 나타낼 때 사용된다.

### 테이블

부호가 없는 숫자나 또 다른 테이블로 구성된 복합 데이터 타입을 나타낸다.  
테이블의 이름은 관례적으로 _info로 끝난다.

### 매직 넘버와 클래스 파일 버전

클래스 파일은 매직 넘버로 시작한다.  
여기서 매직 넘버란 가상 머신이 허용하는 클래스 파일인지 식별하는 역할을 한다.  
클래스 파일의 매직 넘버는 `0xCAFEBABE`이다.

### 상수 풀

상수 풀은 클래스 파일의 자원 창고라고 할 수 있다.  
다른 클래스와 가장 많이 공유되고 클래스 파일에서 가장 먼저 등장하는 테이블 타입 데이터 항목이다.  
일반적으로 상수의 인덱스 범위는 1~18이며 상수 풀 항목을 참조하지 않음을 표현해야하는 경우에만 `0`을 사용한다.  
상수 풀 안에 상수들은 각각 테이블로 구성되어 있다.  
상수 풀은 아래와 같은 종류로 구성된다.

- 모듈에서 익스포트하는 패키지나 모듈의 이름
- 클래스나 인터페이스의 완전한 이름
- 필드나 메서드의 이름과 서술자
- 메서드 핸들과 메서드 타입
- 동적으로 계산되는 호출 사이트와 상수

### 접근 플래그

접근 플래그는 클래스나 인터페이스의 접근 정보를 나타낸다.  
접근 플래그는 `public`, `static`, `final`, `annotation`, `abstract`, `interface`, `super`, `enum`, `module` 등이 있다.

### 클래스 인덱스, 부모 클래스 인덱스, 인터페이스 인덱스

이 정보들은 상속 관계를 나타낸다.  
모든 객체들은 `java.lang.Object` 클래스를 상속받는다.  
그래서 클래스 인덱스는 `java.lang.Object` 클래스를 가리키는 인덱스를 가지고 있고 부모 클래스 인덱스는 `java.lang.Object` 클래스를 가리키는 인덱스를 가지고 있다.  
그렇다보니 예외적으로 `java.lang.Object` 클래스는 부모 클래스 인덱스가 `0`이다.

### 필드 테이블

필드 테이블은 클래스나 인터페이스 안에 선언된 변수들을 설명한다.  
java 언어에서 필드가 어떤 정보를 담고 있는지 생각해보면 이해하기 쉽다.

1. 필드의 접근 제어자(public, private, protected)
2. 인스턴스 변수와 클래스 변수의 구분(static)
3. 불변 여부(final)
4. CPU 캐시가 아닌 메인 메모리를 직접 읽거나 쓰게하는 휘발성(volatile)
5. 직렬화 시 포함 여부(transient)
6. 데이터 타입(기본 타입, 참조 타입)
7. 필드의 이름

### 메서드 테이블

메서드 테이블은 필드 테이블의 구조와 완전히 같다.  
또 각 데이터 항목도 매우 유사하다.  
접근 플래그와 속성 테이블 컬렉션에서 선택할 수 있는 값만 조금 다르다.  
메서드에는 `volatile과 transient` 플래그가 없고, 필드 테이블에 없는 `synchronized` 플래그가 있다.

### 속성 테이블

속성 테이블은 클래스나 인터페이스에 대한 부가 정보를 제공한다.  
최초의 Java 가상 머신 명세에는 속성 테이블에 정의된 속성이 9개였지만 JDK 21에서는 총 30개로 늘어났다.  

#### Code 속성

Code 속성은 Java 클래스 파일에서 메서드의 바이트코드를 설명하는 핵심적인 속성이다.  
JVM이 메서드를 실행하기 위해 사용하는 정보를 포함하고 있으며, 클래스 파일에서 가장 중요하고 복잡한 구조 중 하나로 간주된다.  
Code 속성은 메서드의 실행 코드를 정의하고 실행에 필요한 메타데이터를 제공한다.  
이 속성은 JVM이 특정 메서드를 호출하고 실행하는 데 필요한 정보를 포함한다.

#### Exception 속성

Exception 속성은 메서드가 던지는 예외를 설명한다.  
메서드에서 throw 될 수 있는 검사 예외인 throws 절을 나타낸다.  

#### LineNumberTable 속성

LineNumbeTable 속성은 디버깅에 필요한 정보를 제공한다.(소스 코드의 줄 번호와 바이트 코드의 명령어 주소를 매핑)  
이 속성을 생성하지 않으면 프로그램에서 예외가 발생했을 때 오류를 일으킨 줄 번호가 스택 트레이스에 나타나지 않는다.  
디버깅 할 때도 자바 소스의 특정 줄에 중단점을 설정할 수 없다.  

#### ConstantValue 속성

정적 변수에 값을 자동으로 할당하도록 가상 머신에 알린다.  
static 키워드로 선언된 변수에만 적용되고 인스턴스 생성시 생성자에서 수행된다.  
또 final static으로 선언한 기본형, String 타입의 변수는 ConstantValue 속성을 이용해서 초기화 한다.  

#### InnerClasses 속성

InnerClasses 속성은 클래스의 내부 클래스를 설명한다.  
좀 더 디테일하게 말하자면 내부 클래스와 외부 클래스 사이의 연결 관계를 기록한다.  
내부 클래스를 정의하면 컴파일러가 InnerClasses 속성을 자동으로 생성한다.  

#### Deprecated 속성, Synthetic 속성

Deprecated 속성은 클래스나 메서드가 더 이상 사용되지 않음을 나타낸다.  
Synthetic 속성은 컴파일러가 추가한 필드나 메서드를 나타낸다.  
소스 코드로부터 생성되지 않은 필드나 메서드는 모두 Synthetic 속성을 가지지고 ACC_SYNTHETIC 플래그를 가진다.  
생성자인 <init> 메서드나 클래스 초기화 블록인 <clinit> 메서드는 예외적으로 ACC_SYNTHETIC 플래그를 가지지 않는다.  

#### StackMapTable 속성

StackMapTable 속성의 역할은 가상 머신이 클래스를 로드할 때 바이트 코드 검증을 수행할 있도록 활용된다.  
컴파일 단계에서는 검증 타입을 클래스 파일에 기록한다.  
그래서 런타임 시에는 타입을 추론하는 대신 클래스 파일에 기록된 타입을 사용헤서 성능적으로 이점을 얻을 수 있다.  

#### Signature 속성

Signature 속성은 제네릭 타입을 설명한다.
Signature 속성이 없었을 때는 타입 소거 때문에 리플렉션을 사용해도 제네릭 타입을 알 수 없었다.  
Signature 속성이 추가되면서 리플렉션으로 제네릭 타입을 알 수 있게 되었다.  

#### BootstrapMethods 속성

BootstrapMethods 속성은 람다 표현식과 동적 메서드 호출을 지원하기 위해 추가되었다.  

#### MethodParameters 속성

메서드가 받는 매개 변수 각각의 이름과 정보를 기록한다.  
자바 초기에는 저장 공간을 절약하기 위해 매개 변수 이름이 클래스 파일에 포함하지 않았다.  

#### 모듈화 관련 속성

모듈화 관련 속성은 Java 9에서 모듈 시스템이 도입되면서 추가되었다.  
그래서 모듈 설명 파일인 module-info.java 파일도 독립된 클래스 파일로 컴파일 되어 저장된다.  

#### 런타임 어노테이션 속성

Java 5에서 어노테이션을 도입하면서 런타임 어노테이션 속성이 추가되었다.  
리플렉션 API를 사용해 런타임에 어노테이션 정보를 읽을 수 있다.  

#### Record 속성

Record 속성은 Java 16에서 추가된 불변 객체 타입을 정의하는 class다.  
property가 선언된 순서대로 components 배열의 순서가 결정된다.  

#### PermittedSubclasses 속성  

Java 17에서 추가된 PermittedSubclasses 속성은 sealed 클래스와 sealed 인터페이스를 정의한다.  
여기서 sealed 클래스는 자신을 상속할 수 있는 클래스를 제한하고, sealed 인터페이스는 자신을 구현할 수 있는 클래스를 제한한다.  

## 바이트 코드 명령어 소개

### 로드와 스토어 명령어

로드와 스토어 명령어는 스택 프레임의 로컬 변수와 피연산자 스택 사이에서 데이터를 주고 받는다.  
로드 명령어는 로컬 변수에서 값을 가져와서 피연산자 스택에 넣는다.  
스토어 명령어는 피연산자 스택에서 값을 가져와서 로컬 변수에 넣는다.  

### 산술 명령어

산술 명령어들은 피연산자 스택의 값 두 개를 이용해서 특정한 산술 연산을 수행하고 그 결과를 다시 피연산자 스택에 맨 위에 저장한다.  
산술 명령어는 일반적으로 정수 데이터를 다루는 부류와 부동 소수점 데이터를 다루는 부류로 나뉜다.  
이 부류는 오버플로우 상황이나 0으로 나누는 상황을 처리하는 방법이 다르다.  
여기서 오버플로우가 발생하는 상황은 큰 정수 데이터 두 개를 더하면 음수가 나오는 경우이다.  
이 경우 문제는 오버플로우 되었을 때 어떤 결과를 내야하는지 정의되어 있지 않다.  
한편 0으로 나누는 상황은 ArithmeticException을 발생시키게 메뉴얼이 정의되어 있다.  
또 부동 소수점 데이터를 다루는 산술 명령어는 NaN(Not a Number)이나 무한대를 다루는 방법이 정의되어 있다.  

참고하면 좋은 사항인데, 표현 가능한 두 값이 수학적으로 정확한 값과 차이가 똑같다면 최하위 비트가 0인 값을 선택한다.  
이렇게 하면 계산 결과가 일관성 있게 나온다.  
그리고 부동 솟점 수를 정수로 변환할 때는 0에 가까운 값을 반올림 한다.(양수면 내림, 음수면 올림)  
예시를 들어보면 1.5는 1로, -1.5는 -1로 변환된다.  
0에 가까운 값으로 반올림을 하는 이유는 대상 숫자 타입이 표현할 수 있는 숫자 중에 정확한 값과 가장 가까우면서 더 크지 않은 값이기 때문이다.