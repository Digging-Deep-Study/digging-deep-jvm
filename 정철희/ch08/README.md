# 바이트 코드 실행 엔진

## 런타임 스택 프레임 구조

자바 가상 머신은 메서드를 가장 기본적인 실행 단위로 사용하며 메서드 호출과 실행을 위해 스택 프레임을 사용한다.
스택 프레임은 메서드의 지역 변수 테이블, 피연산자 스택, 동적 링크, 반환 주소 등의 정보를 저장하는 자료구조이다.  
메서드 호출 시작부터 종료하는 과정은 스택 프레임을 가상 머신 스택에 쌓았다가 제거하는 과정이다.

### 지역 변수 테이블

메서드의 매개 변수와 메서드 안에서 정의된 지역 변수를 저장하는 공간이다.  
기본적으로 인스턴스 메서드의 지역변수 슬롯에는 가장 위 스택 프레임에 this가 저장되고 그 다음부터 매개 변수와 지역 변수가 저장된다.  
가장 위에 this가 저장되기 때문에 메서드 안에서 this 키워드를 사용할 수 있다.  
또 변수 슬롯은 재활용이 가능해서 공간을 절약할 수 있지만 gc에 영향을 줘서 문제가 발생할 수 있다.  
그래서 수동으로 인스턴스에 null을 대입해서 참조를 제거하는 방법이 있다.
예전에는 이 방법을 권장 했지만 현재 이 규칙은 굳이 지킬 필요가 없다.  
대신 변수 범위를 적절하게 지정해서 변수가 회수되는 시간을 최소화하는 것이 중요하다.  
그리고 문제 사항 중 하나인 jit 컴파일러가 최적화를 진행하면서 null을 대입하는 코드를 제거할 수 있기 때문에 이 방법을 사용하지 않는 것이 좋다.

### 피연산자 스택

연산을 수행하는데 사용하는 스택이다.  
스택 프레임 가장 위에 존재하는 데이터들을 연산할 때 사용한다.  
그리고 연산 결과를 다시 스택 프레임 가장 위에 저장한다.  
이렇다보니 원소의 데이터 타입은 바이트코드 명령어의 순서와 정확하게 일치해야 한다.  
컴파일러는 이러한 규칙을 지키기 위해 연산을 수행할 때마다 스택 프레임의 상태를 확인하고 연산을 수행한다.

### 동적 링크

메서드에서 이용하는 외부 클래스나 메서드를 가르키는(참조) 정보를 저장하는 공간이다.  
외부 클래스나 메서드를 가르키는(참조) 정보는 일반적으로 런타임 상수 풀에 저장되어 있다.

### 반환 주소

메서드를 종료하는 방법은 2개이다.  
첫 번째는 실행 엔진이 반환 바이트코드 명령어를 만나면서 메서드가 정상적으로 종료된다.  
두 번째는 예외가 발생하고 예외 처리가 제대로 되지 않으면 종료된다.    
예외로 인해 종료되는 메서드는 호출자에게 반환값을 전달하지 않는다.  
그리고 둘 다 메서드가 종료되면 메서드를 호출한 위치로 돌아가야 하는데 이때 사용하는 정보가 반환 주소이다.  

### 해석

메서드 호출 대상은 모두 클래스 파일의 상수 풀에 심벌 참조로 저장되어 있다.  
그래서 어떤 메서드들은 클래스 로딩 시점에 상수 풀에 저장되어 있는 참조값을 확인 할 수 있다.  
이런 호출 대상이 미리 특정 되는 경우를 정적 해석이라고 하고 이런 호출 대상이 런타임 시점에 결정되는 경우를 동적 해석이라고 한다.  
자바 언어는 `컴파일 타임에 알 수 있고 런타임에 변경될 수 없다`라는 규칙을 따르는 대표적인 메서드들이 정적 메서드와 private 메서드이다.    

### 디스패치 

TODO

### 동적 타입 언어 지원

자바는 정적 타입 언어이지만 동적 타입 언어를 지원하기 위해 `invokedynamic` 명령어를 제공한다.  
jdk 7부터 지원하는 명령어로 런타임 시점에 동적으로 호출할 메서드를 결정한다.  
이 명령어는 `MethodHandle`을 이용해서 메서드를 호출하고 `CallSite`를 이용해서 호출 대상을 결정한다.  
`invokedynamic` 명령어 덕분에 자바는 동적 타입 언어를 지원할 수 있게 되었고 이를 이용해서 람다식을 구현할 수 있다.   
동적 타입을 지원하면서 링크 타임 예외가 발생할 수 있고 링크 타임 예외는 `예외를 일으키는 코드가 결코 실행되지 않는 경로에 존재하더라도 클래스가 로딩 될 때 발생하는 예외`이다.  
대표적으로 `NoClassDefFoundError`가 있다.  

### 자바와 동적 타이핑

jvm 위에서 동작하는 동적 타입 언어들 중에서 `jruby`, `jython`, `groovy` 등이 `invokedynamic` 명령어를 이용해서 구현되어 있다.
근데 꼭 장점만 있는 것은 아니다.  
동적 타입 언어가 지원되면서 호출 대상을 런타임에 결정해야 하기 때문에 성능이 떨어지고 복잡성, 메모리 사용량이 증가한다.  
런타임에 결정 된다는 것은 리플렉션을 이용해서 메서드를 호출하는 것과 같은 비용이 발생한다.  
실제로 동작 원리는 비슷하다고 볼 수 있다.  
이러다보니 동적 타입 언어 호출의 근본적인 문제는 결구 jvm level에서 해결해야한다.  
가상 머신이 동적 타입을 지원하지 않으면 자바 플랫폼이 발전하기 어렵다고 판단해서 이렇게 구현한 것 같다.  

### invokedynamic 명령어

TODO