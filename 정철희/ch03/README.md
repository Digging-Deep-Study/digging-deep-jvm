# 가비지 컬렉터와 메모리 할당 전략

## 대상이 죽었는가?

Java는 객체 인스턴스가 힙에 저장이 되고 가비지 컬렉터가 이 객체를 관리한다.  
여기서 관리란 객체가 더 이상 사용되지 않는다고 판단되면 가비지 컬렉터가 이 객체를 메모리에서 해제하는 것을 말한다.  

### 카운팅 알고리즘

객체를 가리키는 참조 카운터를 추가하고 참조 하는 곳이 늘어 날때 마다 카운터를 증가시키고 참조가 끊어질 때마다 카운터를 감소시킨다.  
카운터 값이 0이 된다면 가비지 컬렉터가 이 객체를 해제한다.  
파이썬, 러스트와 같은 언어들은 이 알고리즘을 사용하지만 Java는 이 카운팅 알고리즘을 사용하지 않는다.  
왜냐하면 이 알고리즘은 특정 사항을 문제 없이 처리할 수 없고 대표적으로 순환 참조를 해결할 수 없기 때문이다.

### 도달 가능성 분석 알고리즘

Java는 도달 가능성 분석 알고리즘을 사용한다.  
도달 가능성 분석 알고리즘은 루트 집합에서 시작해서 도달 가능한 객체를 찾는다.  
이 도달 가능한 경로를 참조 체인이라 하고 이 체인이 끊어지면 더이상 참조 된 객체가 없다고 판단하고 가비지 컬렉터가 이 객체를 해제한다.  
여기서 루트 집합은 GC 루트라고도 하며 다음과 같은 것들이 GC 루트에 해당한다.  

- 가상 머신 스택
- 메서드 영역에서 클래스가 정적 필드로 참조하는 객체
- 메서드 영역에서 상수로 참조되는 객체
- 네이티브 메서드에서 JNI(Java Native Interface)로 참조하는 객체
- Java 가상 머신 내부에서 쓰이는 참조
- 동기화 락으로 잠겨있는 객체

### 참조

객체는 `참조됐다`, `참조되지 않았다`라는 두 상태만 있고 `버리기는 아까운 객체`를 표현 할 수 없었다.  
JDK 1.2부터는 `GC가 일어나고도 메모리가 부족할 때 회수하는 객체`를 표현 하기 위해 참조를 4가지로 나누었다.  

- 강한 참조 : `String a = new "강한참조"`와 같이 코드에서 참조를 할당하고 이 관계가 남아있다면 절대 회수하지 않는다.
- 부드러운 참조 : 유용하지만 필수는 아닌 객체로 메모리 오버 플로우가 발생하기 직전에 이 객체를 해제한다.
- 약한 참조 : 부드러운 참조보다 연결 강도가 더 낮은 참조로 메모리가 여유가 있다면 첫번째 GC에서는 살아남고 2번째 GC에서 해제된다.
- 유령 참조 : 객체 수명에 아무런 영향을 주지 않고 객체가 회수 될 때 알림을 받기 위해 사용한다.

## 가비지 컬렉션 알고리즘

### 세대 단위 컬렉션 이론

현재 상용 중인 가상 머신들이 사용하는 가비지 컬렉션 알고리즘은 대부분 세대 단위 컬렉션 이론을 기반으로 한다.  
세대 단위 컬렉션 이론은 두 가지의 가정이 중요하다.

1. 약한 세대 가설 : 대부분의 객체는 일찍 죽는다.
2. 강한 세대 가설 : GC에서 살아 남은 횟수가 늘어날 수록 오래 살아남을 확률이 높아진다.

여기서 위 이론을 보고 살아남는 소수의 객체를 유지하는 방법이 효율적이라고 생각할 수 있다.  
풀어서 말을 하면 GC에서 살아남은 객체는 잘 죽지 않으니 다른 영역에 따로 모아서 그 영역에 GC 빈도를 낮추는 것이다.  

그래서 GC 과정은 크게 3가지로 나뉜다.

- 마이너 GC : 신세대 영역에서 일어나는 GC
- 메이저 GC : 구세대 영역에서 일어나는 GC
- 전체 GC : 전체 영역에서 일어나는 GC

마이너 GC가 일어나면 신세대 영역만을 대상으로 해야하는데 문제는 참조다.  
세대 간의 참조의 개수는 세대 안에서의 참조보다 훨씬 적긴 하지만 이 문제를 해결하지 못하면 매번 전체 영역을 대상으로 GC를 수행해야 한다.  
구세대 영역에서 신세대 영역을 참조하는 객체가 있을 수 있기 때문에 이를 해결하기 위해 `기억 집합`을 사용한다.  
구세대를 작은 테이블 형태로 만들어서 신세대 영역을 참조하는 객체를 기억하고 있다가 마이너 GC가 일어나면 이 테이블을 참조해서 신세대 영역을 참조하는 객체를 찾아내고 이 객체를 구세대 영역으로 옮긴다.  

### 마크-스윕 알고리즘

마크-스윕 알고리즘은 가장 간단한 가비지 컬렉션 알고리즘이다.  
회수 할 객체들을 표시하고 표시한 객체만 회수하는 방식이다.  
반대로 회수하지 않을 객체를 표시하는 방식도 있다.  
근데 이 방식의 문제는 대부분이 가비지일 때는 표시, 회수 하는 빈도가 높아진다.  
그리고 메모리 파편화가 심해서 GC가 일어나면 메모리를 정리하는 작업이 필요하다.  
그렇지 않다면 큰 객체를 할당 해야할 때 메모리 파편화로 인해 할당이 안될 수 있다.  

### 마크-카피 알고리즘

마크-카피 알고리즘은 마크-스윕 알고리즘의 문제점을 해결하기 위해 나왔다.  
한쪽 메모리 블록이 가득찬다면 살아남은 객체를 다른 메모리 블록으로 복사하고 가득 찬 메모리를 한번에 청소하는 방식이다.  
이 알고리즘은 살아남은 객체들을 차례차례 쌓기 때문에 메모리 파편화를 해결하고 할당 속도도 빠르다.  
그런데 문제는 메모리 절반을 사용하기 때문에 메모리 사용량이 엄청나게 늘어난다.  
또한 객체의 생존률이 높을 수록 복사 할 객체가 많아서 성능이 떨어진다.  

핫스팟VM에서 GC가 일어나면 `일반적`으로 98% 이상의 비율로 객체를 회수한다.  
그래서 많은 객체를 회수하기에 마크-스윕 알고리즘을 잘 사용하지 않는다.  
이어서 말을 하자면 GC가 일어났을 때 살아남은 객체들이 있어야하는 생존자 역역은 전체 신세대 영역의 10%를 할당 받는다.  
물론 일반적인 상황에서 98% 이다보니 예외상황에서 이 비율을 높일 수 있다.(VM 옵션으로 조정 가능)

### 마크-컴팩트 알고리즘

마크-카피 알고리즘의 문제인 객체의 생존률이 높을 때 떨어지는 성능과 메모리 영역의 50% 낭비를 해결하기 위해 나왔다.  
기본적으로 마크-컴팩트 알고리즘은 마크-스윕 알고리즘 처럼 표시를 하고 살아남은 객체를 다른 메모리 한쪽 끝으로 모은 다음 나머지 공간을 통으로 비운다.  
이 알고리즘의 특징은 메모리 이동이 일어난다는 점이다.  
이 메모리 이동이 일어날 때는 stop-the-world가 발생한다.
그래서 이전 핫스팟VM에서는 대부분의 상황에서 stop-the-world를 줄이기 위해 메모리 파편화를 감내하면서 마크-스윕 알고리즘을 사용하다가 파편화가 심해지면 그 때 마크-컴팩트 알고리즘을 사용한다.  

[//]: # (## 핫스팟 알고리즘 상세 구현)

[//]: # (### 루트 노드 열거)

[//]: # ()
[//]: # (루트 노드 열거는 GC 루트에서 시작해서 참조하는 객체를 찾는 것이다.  )

[//]: # (그런데 메서드 영역의 크기가 매우 큰 경우 이 영역을 모두 찾아야 하는데 이는 매우 비효율적이다.  )

[//]: # (다행히도 가장 오래걸리는 작업은 User Thread와 동시에 실행이 가능하다.)

[//]: # ()
[//]: # (### 안전 지점)

[//]: # ()
[//]: # (### 안전 지역)

[//]: # ()
[//]: # (### 기억 집합과 카드 테이블)

[//]: # ()
[//]: # (### 쓰기 장벽)

## 클래식 가비지 컬렉션

### 시리얼 컬렉터
단일 스레드로 작동하며 새로운 객체를 할당할 때 stop-the-world가 발생한다.  
메모리 사용률이 가장 적기 때문에 가용 메모리가 적은 경우에 사용하면 좋다.  

### 파뉴 컬렉터
멀티 스레드로 시리얼 컬렉터들을 병렬화 한 버전이다.  
스레드 회수에 멀티 스레드를 사용한다는 점만 제외하면 시리얼 컬렉터와 같다.  
즉 병렬 처리 말고는 차이가 없다. (사실상 실패작)

### 패러럴 스캐빈지 컬렉터
신세대 영역에서 사용하는 컬렉터이며 처리량을 제어하는 것을 목표로 설계되었다.  
여기서 처리량은 `사용자 코드 실행 시간 / (사용자 코드 실행 시간 + GC 실행 시간)`이다.
처리량이 빠른게 무조건 적으로 좋지만 처리량이 좋다는건 프로세서 자원을 많이 사용한다는 것이다.  
그래서 처리량을 제어하는 것이 중요하다.  

### 시리얼 올드 컬렉터
시리얼 컬렉터의 구세대 버전이다.  
단일 스레드로 작동하며 마크-컴팩트 알고리즘을 사용한다.  
뒤에 나올 CMS 컬렉터와 함께 사용되며 CMS 컬렉터가 동시 회수를 하다가 실패했을 때 사용된다.  

### CMS 컬렉터

사용자 스레드와 동시에 작동하는 컬렉터이다.  
stop-the-world 시간을 줄이기 위해 설계 되었으며 응답 시간을 최소화 하는 것이 목표이다.  
CMS의 동작 방식은 `최초 표시 -> 동시 표시 -> 재표시 -> 동시 쓸기`로 구성된다.  
최초 표시와 재표시는 stop-the-world가 발생하지만 GC 루트와 직접 연결된 객체들만 표시하기 때문에 그 시간은 매우 짧다.  
동시 표기는 사용자 스레드와 함께 작동하며 stop-the-world가 발생하지 않지만 시간이 오래 걸린다.  
재표시는 동시 표시 단계에서 사용자 스레드가 객체의 참조 관계를 변경 했을 때 이를 바로 잡기 위해 사용된다.  
동시 쓸기는 위 모든 표시 작업에서 죽었다고 판단된 객체를 회수하는 단계이다.  
중요한 특성은 작업 시간이 가장 긴 동시 표시와 동시 쓸기가 사용자 스레드와 함께 작동해서 정지 시간을 최소화 한다.  
하지만 동시성을 위해 설계되었다보니 프로세서 자원에 민감하다.(GC Thread도 결국 프로세서의 계산 능력을 나눠 쓰는 것이기 떄문)   
CMS의 스레드 수는 (CPU core 수 + 3) / 4 이다.  
CPU 코어가 적을 수록 처리량이 엄청나게 떨어지기 때문인데 예를 들어 4코어 CPU라면 GC Thread가 계산 능력을 25%를 사용한다.  

### G1 컬렉터

가비지 컬렉터 중에서 역사의 한 획을 그은 컬렉터이다.  
G1 컬렉터는 세대 단위 컬렉션 이론을 사용하지 않고 리전이라는 영역 단위로 힙영역을 관리한다.    
어느 영역에서 가비지가 많이 발생했는지 파악하고 그 영역을 대상으로 GC를 수행하며 이것을 `혼합 GC 모드`라고 한다.  
리전은 필요에 따라 신세대 영역이나 구세대 영역으로 변환된다.  
리전을 최소 회수 단위로 사용하기 때문에 자바 힙 영역 전체를 대상으로 GC를 수행하지 않아도 된다.  
하지만 이 컬렉터에도 문제는 당연히 존재한다.  

1. 리전간 참조 문제
2. 동시 표시 단계 동안 사용자 스레드와 GC 스레드가 서로 간섭하지 않아야 한다.
3. 정지 시간 예측 모델을 구현해야 한다.

G1 컬렉터의 동작 방식은 `최초 표시 -> 동시 표시 -> 재표시 -> 복사 및 청소`로 구성된다.  
복시 및 청소 단계를 제외하면 CMS 컬렉터와 대부분 동일하다.  
G1 컬렉터는 복사 및 청소 단계에서는 회수 가치와 비용에 따라 줄 세운 뒤 회수 계획을 세운다.  
살아 남은 객체들은 빈 리전으로 이전시키고 이 때 stop-the-world가 발생한다.  
하지만 다행히도 병렬로 처리하기 때문에 stop-the-world 시간이 매우 짧다.  
G1의 가장 큰 장점은 정지 시간의 기댓값을 사용자가 설정할 수 있다는 것이다.  
이 값을 잘 지정하면 처리량 대 지연시간 균형점을 찾을 수 있다.  
하지만 반대로 이 값을 잘못 지정하면 처리량이 떨어지거나 지연 시간이 길어진다.  
예를 들자면 쓰레기를 다 회수하지 못했는데 GC가 끝나고 이 작업이 반복 되다 보면 메모리가 부족해지고 결국 전체 GC가 일어나서 성능을 떨어트린다.

## 저지연 가비지 컬렉션

### 셰넌도어
셰넌도어는 오라클이 아닌 다른 회사에서 만든 가비지 컬렉터이다.  
셰넌도어의 동작 방식은 `최초 표시 -> 동시 표시 -> 최종 표시 -> 동시 청소 -> 동시 이주 -> 최초 참조 갱신 -> 동시 참조 갱신 -> 최종 참조 갱신 -> 동시 청소`로 구성된다.  
9단계로 구성 되어 있지만 동시 표시, 동시 이주, 동시 참조 갱신이 여기서 중요한 부분이다.  
동시 표시는 위에 다른 컬렉터들과 거의 동일하고 동시 이주는 살아남은 객체를 다른 공간으로 이동시키는 단계이다.  
동시 참조 갱신은 살아남은 객체가 이동했을 때 참조를 갱신하는 단계이다.
셰넌도어가 동시 처리를 하는 방법 중에 가장 인상적이었던건 스택 워터마크를 통해서 GC 스레드와 사용자 스레드의 간섭을 막는 방법이다.  
스택 워터마크란 GC가 일어나면 자바의 모든 스레드들의 스택을 복사한다.  
그리고 스택 가장 윗 부분에 표시를 하고 이 표시이후에 쌓이는 스택은 사용자 스레드가 쌓는 스택이라고 판단한다.  
그래서 GC 스레드는 이 표시 이전에 쌓인 스택만을 대상으로 GC를 수행한다.

### ZGC
ZGC는 오라클이 만든 가비지 컬렉터이다.  
리전 기반의 메모리 레이아웃 구조를 사용하며 리전을 최소 단위로 GC를 수행한다.  
ZGC는 병렬 모으기, 컬러 포인터와 같은 기술을 사용한다.  
여기서 컬러 포인터는 객체의 상태를 나타내는 비트를 포인터에 추가하는 기술이다.  
ZGC의 동작 방식은 `표시 시작 -> 동시 표시 -> 표시 종료 -> 동시 재배치 준비 -> 재배치 시작 -> 동시 재배치 -> 동시 재매핑`으로 구성된다.  
우리가 알아야할 것은 동시 재배치 준비와 동시 재배치, 동시 재매핑이다.  
동시 재배치 준비는 청소해야할 리전들을 선정해서 재배치 집합을 만든다.  
동시 재배치는 살아남은 객체들을 새로운 리전으로 복사한다.  
그리고 이주하기 전인 옛날 객체와 새 객체의 이주 관계를 기록한다.  
동시 재매핑은 재배치 집합에 있는 옛 객체들을 향하는 참조 작업을 전부 갱신한다.  
원래 ZGC는 세대 구분을 하지 않았는데 최근 세대 구분 ZGC를 계속해서 지원하고 있다.

## 적합한 가비지 컬렉션 선택

### 컬렉터 비교
그러면 언제 어떤 상황에서 어떠한 컬렉터를 사용해야 할까?  
일반적으로는 다음과 같은 상황에서 다음과 같은 컬렉터를 사용하면 된다.  

- 최대 100MB 정도의 데이터를 다루는 어플리케이션 : 시리얼 컬렉터
- 어플리케이션이 단일 프로세서만 사용하고 일시정지 시간 관련 제약이 없는 경우 : 시리얼 컬렉터
- 어플리케이션의 성능이 가장 중요하고 지연 시간 관련 제약이 없거나 1초 이상의 지연 시간도 허용이 된다면 : 패러럴 스캐빈지 컬렉터  
- 처리량보다 응답 시간이 중요하고 가비지 컬렉션에 따른 일시 정지 시간이 짧아야한다면 : G1
- 응답 시간이 매우 중요하다면 : ZGC

### 컬렉터 로그 
일반적으로 GC 로그는 slf4j나 log4j랑 비슷하게 trace, debug, info, warn, error, off 레벨로 나뉜다.

## 메모리 할당과 회수 전략

### 객체는 먼저 에덴에 할당된다
대부분에 경우 객체가 생성이 된다면 에덴 영역에 할당하고 이 영역이 가득 차면 마이너 GC가 일어난다.

### 큰 객체는 바로 구세대에 할당된다
큰 객체란 커다란 연속된 메모리 공간을 필요로 하는 객체를 말한다.  
매우 긴 문자열이나 원소가 많은 배열 등이 이에 해당한다.  
그래서 VM 옵션에서 특정 값보다 큰 객체는 바로 구세대에 할당 할 수 있는 설정을 지원한다.  

### 나이가 차면 구세대로 옮겨진다
객체 헤더에는 GC가 일어난 횟수를 기록하는 나이 필드가 있다.  
태어날 땐 0이고 GC가 일어나고 살아있을 때마다 1씩 증가한다.  
이 나이가 특정 값 이상이 되면 구세대로 이동한다.

### 공간이 부족하면 강제로 승격시킨다
구세대로 옮기는 조건이 객체 크기와 나이뿐만이 아니라 공간이 부족해도 강제로 승격시킨다.  
생존 객체 전체의 크기가 생존자 공간 크기에 절반 이상이면 모든 객체를 구세대로 옮긴다.  
