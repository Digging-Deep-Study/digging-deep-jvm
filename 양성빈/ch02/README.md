> 이 포스팅은 [JVM 밑바닥까지 파헤치기](https://ebook.insightbook.co.kr/book/164)책을 참고하여 작성된 글이다.

# 자바 메모리 영역과 메모리 오버플로

## 들어가며

메모리 관리 측면에서 C,C++ 개발자는 전권을 가진 황제인 동시에 잡다한 막노동도 직접 하는 일꾼이라 할 수 있다.

자바 개발자는 가상머신이 제공하는 자동 메모리 관리 메커니즘 덕에 메모리 할당과 해제를 짝지어 코딩하지 않아도 메모리 누수나 오버플로 문제를 거의 겪지 않는다. 하지만 이에 대한 단점으로 문제가 터지면 가상 머심의 메모리 관리 방식을 이해하지 못하는 한 해결하기가 상당히 어렵다는 점이다.

## 런타임 데이터 영역

자바 가상 머신은 자바 프로그램을 실행하는 동안 필요한 메모리를 몇개의 데이터 영역으로 나눠 관리한다. 각각 영역들은 목적과 생성/삭제 시점이 있고 영역마다 다르다.

![자바 가상 머신 런타임 데이터 영역](./assets/01.png)

### 프로그램 카운터(PC)

PC는 다음에 실행할 바이트코드의 명령어를 선택하는 식으로 동작한다. 예외처리나 스레드 복원 같은 모든 기본 기능이 바로 이 표시기를 활용해 이루어진다.

PC는 각 스레드마다 고유한 PC가 필요하므로 스레드 프라이빗 메모리에 저장된다. 또한 스레드가 자바 메서드를 실행 중일때는 실행 중인 바이트코드 명령어 주소가 PC에 기록된다. 한편 스레드가 네이티브 메서드를 실행할 때는 PC 값은 undefined이다.

### 자바 가상 머신 스택

자바 가상 머신 스택도 스택 프라이빗 하다. 각 메서드가 호출될 때마다 자바 가상 머신은 스택 프레임을 만들어 지역 변수 테이블, 피연산자 스택, 동적 링크, 메서드 반환 값등의 정보를 저장한다.

사람들은 자바의 메모리 영역을 스택과 힙으로만 구분하는데 자바 메모리 영역 구분은 훨씬 복잡하다. 하지만 이 2가지가 강조되는 이유는 스택과 힙이 객체 메모리 할당과 가장 밀접해서이지 않을까?

스택의 지역 변수 테이블에는 자바 가상 머신이 컴파일 타임에 알 수 있는 기본 데이터 타입, 객체 참조, 반환 주소 타입을 저장한다. 이것들을 저장하는 공간을 지역 변수 슬롯이라 하며 일반적으로 32bit이다. 또한 지역 변수 테이블을 구성하는 데 필요한 데이터 공간은 컴파일 과정에서 할당된다.

자바 가상 머신은 스택 메모리 영역에서 2가지 오류가 발생 할 수 있다.

- StackOverflowError: 스레드가 요청한 스택 깊이가 가상 머신이 허용하는 깊이보다 클때 예외를 던진다.
- OutOfMemoryError: 스택 용량을 동적으로 확장할 수 있는 자바 가상 머신에서 스택을 확장하려는 시점에 여유 메모리가 충분하지 않다면 예외를 던진다.

### 네이티브 메서드 스택

가상 머신 스택과 유사. 네이티브 메서드를 실행할때 사용된다. 자바 가상 머신 명세에 어떤 구조로 어떻게 표현해야한다는 것이 명시되어 있지 않아 구현자가 원하는 형태로 자유롭게 표현이 가능. 그래서 네이티브 메서드 스택과 가상 머신 스택을 합쳐놓은 핫스팟 VM등도 있다.

### 자바 힙

자바 힙은 자바 애플리케이션이 사용할 수 있는 가장 큰 메모리다. 이 영역은 객체 인스턴스를 저장하는 것이고 **거의** 모든 객체 인스턴스가 이 영역에 저장된다. 여기서 **거의**라고 표현한 이유는 기술이 점점 발전함에 따라 모든 객체가 저장된다는것은 절대적 진리가 될 수 없기 때문이다.

자바 힙은 가비지 컬렉터가 관리하는 메모리 영역이기 때문에 GC힙이라고도 부른다.

여러 문헌에서 자바 가상 머신의 힙 메모리는 신세대, 구세대, 영구 세데, 에덴 생존자 공간등으로 나눈다고 말한다. 과거에는 그랬는지 몰라도 오늘날의 가비지 컬렉터 기술은 그 시절에 머물지 않는다. 심지어 핫스팟에서도 세대 단위 설계를 따르지 않는 컬렉터도 포함되었다.

자바 힙은 모든 스레드가 공유한다. 따라서 객체 할당 효율을 높이고자 스레드 로컬 할당 버퍼 여러개로 나뉜다. 하지만 이렇게 나뉘는 이유는 오직 메모리 회수와 할당을 더 빠르게 하기 위함일뿐 그 이상 그 이하도 아니다.

자바 힙은 물리적으로 떨어진 메모리에 위치해도 상관 없으니 논리적으로는 연속되어야 한다. 하지만 대다수 가상 머신들이 큰 객체는 물리적으로 연속된 메모리 공간을 사용하도록 구현한다. 그 이유는 저장 효율을 높이고 구현 로직을 단순하게 유지하기 위해서이다.

자바 힙은 고정 혹은 확장이 가능하다. -Xms와 -Xmx 매개변수를 사용함으로 확장이 가능하다.

### 메서드 영역

메서드 영역도 모든 스레드가 공유한다. 메서드 영역은 가상 머신이 읽어 들인 타입 정보, 상수, 정적 변수 그리고 JIT 컴파일러가 컴파일한 코드 캐시등을 저장하는데 이용한다.

메서드 영역을 이야기하면 영구 세대 이야기가 꼭 나온다. JDK7까지 많은 개발자들이 메서드 영역과 영구세대를 혼동하였다. 그 이유는 핫스팟 개발팀이 가비지 컬렉터 수집의 범위를 메서드 영역까지 확장했고 그 결과 메서드 영역을 영구세대에 구현하는 후부터다.

JDK6 시절, 영구세대를 포기하고 메서드 영역을 네이티브 메모리에 구현할 계획을 세웠다. 그래서 JDK7에 영구세대에서 관리하던 문자열 상수와 정적 변수등의 정보를 자바 힙으로 옮겨 갔다.

메서드 영역은 자바 힙과 마찬가지로 연속될 필요가 없고 크기를 고정할 수도 있고 확장 가능하게 만들 수도 있다. 심지어 가비지 컬렉션을 하지 않아도 좋다.

### 런타입 상수 풀

런타임 상수 풀은 메서드 영역 일부다. 상수 풀 테이블에는 클래스 버전, 필드, 메서드, 인터페이스등 클래스 파일에 포함된 설명 정보에 더해 컴파일 타임에 생성된 다양한 리터럴과 심벌 참조가 저장된다. 가상 머신이 클래스를 로드할 때 이러한 정보가 상수 풀에 담긴다.

자바 가상 머신은 클래스 파일의 각 영역별로 엄격한 규칙을 정해놓았다. 반면 런타임 상수 풀은 요구사항을 상세하게 정의해두지 않아서 가상 머신 제공자가 입맛에 맞게 구현이 가능하다. 그렇지만 클래스 파일에 기술된 심벌 참조는 물론, 심벌 참조로부터 번역된 직접 참조 역시 런타임 풀에 저장되는게 일반적이다.

런타임 상수 풀은 바로 **동적**이라는 특징이 있다. 런타임에 메서드 영역의 런타임 상수 풀에 새로운 상수가 추가될 수 있다. String 클래스의 `intern()` 메서드가 그 예시이다.

### 다이렉트 메모리

JDK1.4에서 NIO가 도입되면서 채널과 버퍼 기반 I/O 메서드가 소개되었다. NIO는 자바 힙과 네이티브 힙 사이에서 데이터를 복사해 주고받지 않아도 돼서 일부 시나리오에서 성능을 크게 개선했다. 일종의 DMA가 아닐까?
