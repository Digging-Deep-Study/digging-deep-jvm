# Chapter 3

저지연 GC

## 셰넌도어

Open JDK에만 존재하는 저지연 GC

### 특징

- 저지연성
- G1을 계승 (유사한 힙 레이아웃, 최초 표시, 동시 표시). 부분적으로 코드를 공유

### G1과의 차이점

|                  | G1    | 셰넌도어  |
|------------------|-------|-------|
| 동시 모으기 지원        | X     | O     |
| 세대 단위 컬렉션 사용     | O     | X     |
| 리전 간 참조 관계 기록 방식 | 기억 집합 | 연결 행렬 |

### 동작 방식

1. 최초 표시(Init Mark)
    - 힙과 어플리케이션 스레드를 준비하고 루트 집합을 스캔
    - 특징:
        - 중단(pause) 발생
    - 실행시간: 루트 집합의 크기에 따라 비례
2. 동시 표시(Concurrent Marking)
    - 힙을 탐색하고 도달 가능한 객체를 추적
    - 특징:
        - 어플리케이션과 동시(Concurrently)에 실행
        - 어플리케이션의 새 데이터 할당으로 인해 힙 점유율이 증가
    - 실행시간:
        - 힙 내 그래프 구조에 따라 달라짐. (즉, 힙의 크기와 객체의 수에 따라 달라짐)
3. 최종 표시(Final Mark)
    - 동시 표시를 완료한다. 이주 단계를 준비한다. (이주할 영역 결정 등)
    - 특징:
        - 중단(pause) 발생
    - 실행시간:
        - 대기열 비우기
        - 루트 집합 스캔
4. 동시 청소
    - 살아있는 객체가 없는 영역을 회수
    - 특징:
        - 동시 표시 후, 불필요한 영역 감지 및 회수
        - 어플리케이션과 동시(Concurrently) 실행
5. 동시 이주
    - 컬렉션(수집 영역)의 살아있는 객체를 다른 빈 영역으로 이주(복사)
    - 특징:
        - 포워딩 포인터 이용
        - 어플리케이션과 동시(Concurrently) 실행
        - 어플리케이션의 (복사로 인한) 새 데이터 할당으로 인해 힙 점유율이 증가
    - 실행시간:
        - 컬렉션의 크기에 따라 달라짐
6. 최초 참조 갱신
    - 옛 객체를 가리키는 참조를 복사 후 새로운 주소로 갱신하는 과정
    - 특징:
        - 모든 GC 및 어플리케이션 스레드가 이주(복사)를 완료했는지 확인
        - GC를 다음 단계(다음 사이클)로 준비
        - 중단(pause) 발생. 중단 시간이 가장 짧음
7. 동시 참조 갱신
    - 동시 이주 중 이주한 객체에 대한 참조를 업데이트
    - 특징:
        - 힙을 선형적으로 스캔(O(n))
        - 어플리케이션과 동시(Concurrently) 실행
    - 실행시간:
        - 힙 내 객체 수에 따라 달라짐
        - 힙을 선형적으로 탐색하기에, 객체 그래프 구조에는 영향을 받지 않음
8. 최종 참조 갱신
    - 참조 갱신을 완료함
        - 기존 루트 집합 재갱신
        - 수집 영역의 메모리 재활용
    - 특징:
        - 중단(pause) 발생
    - 실행시간:
        - 루트 집합의 크기에 따라 달라짐
9. 동시 청소
    - 이주와 갱신이 끝나면 회수 집합의 모든 리전에는 살아있는 객체가 없기에 동시 청소 재실행
    - 특징:
        - 동시 이주 후, 불필요한 영역 감지 및 회수
        - 어플리케이션과 동시(Concurrently) 실행

![Shenandoah GC](http://cr.openjdk.java.net/~shade/shenandoah/specjbb-preset4K-10min.png)

## ZGC

오라클의 저지연 GC

### 특징

세대 구분 없이 동적 리전 기반 메모리 레이아웃을 사용

### 리전 기반 메모리 레이아웃

- 힙을 리전(Page)으로 나누어 관리. 리전은 동적으로 생성/소멸함
- 리전은 소 - 중 - 대 세 가지 크기로 나눔
    - 소: 2mb
    - 중: 32mb
    - 대: 동적으로 변할 수 있음. 단, 2mb의 배수여야 함

### 컬러 포인터(Colored Pointers)

- 객체의 헤더가 아닌, 객체의 **포인터**에 색상 정보를 추가하여 객체의 상태를 추적
- 주소 공간을 44비트로 제한하여 4비트의 플래그 정보를 추가
    - 플래그 정보 (4비트)
        - Finalizable: 객체가 finalize 메서드를 가지고 있는지 여부
        - Remapped: 이주했는가?
        - Marked1
        - Marked0
- 장점:
    - 재활용성: 생존 객체가 이동과 동시에 해당 리전을 재활용 가능
    - 효율성: GC 중 포인터에 직접 정보를 저장함으로서 메모리 장벽을 줄일 수 있음. 실제로 ZGC는 쓰기 장벽을 사용하지 않음

### 동작 방식

1. 동시 표시
    - 힙을 탐색하고 도달 가능한 객체를 추적
    - 특징:
        - 어플리케이션과 동시(Concurrently)에 실행
        - 표시(Marking)가 객체가 아닌, 포인터에 색상 정보에서 이루어짐
        - Marked0와 Marked1을 이 단계에서 갱신
2. 동시 재배치 준비
    - 청소할 리전들을 선정하여 재배치 집합을 생성
    - 특징:
        - 모든 리전을 스캔 후 리전 자체를 회수할지 여부만을 결정
3. 동시 재배치
    - 생존한 객체들을 새로운 리전으로 복사
    - 특징
        - 자가치유 과정 수행
          - 자가치유:
            1. 사용자 스레드가 객체에 동시 접근
            2. 메모리 장벽을 통해 해당 리전의 포워드 테이블의 정보를 보고 새로운 객체로 포워딩
            3. 해당 객체의 참조를 새로운 객체로 갱신
4. 동시 재매핑
    - 재배치 집합 내의 모든 객체의 참조를 갱신
    - 특징:
        - 셰넌도어의 동시 참조 갱신과 유사하나, 자가치유 덕분에 처리가 시급하지 않음

### 세대 구분 ZGC

기존 ZGC에서 세대 구분을 추가하여, 짧은 수명의 객체들을 자주 회수하도록 함

구현 복잡도로 인하여 미루었으나, 상태계가 성숙해짐에 따라 세대 구분 ZGC가 추가됨