# 11장 백엔드 컴파일과 최적화

바이트코드를 프로그래밍 언어의 중간 표현이라고 생각하면, 컴파일러가 클래스 파일을 로컬 환경(하드웨어 명령어 집합, 운영 체제)에 맞는 네이티브 코드로 변환하는 과정을 전체 컴파일 과정의 백엔드로 간주할 수 있다.

AOT 컴파일러든 JIT 컴파일러든 자바 가상 머신에서 필수는 아니지만, 백엔드 컴파일러의 컴파일 성능과 최적화 품질은 상용 가상 머신의 우수성을 측정하는 핵심 지표다.

백엔드 컴파일러

- JIT 컴파일러 : 핫스팟 가상 머신의 C1·C2 컴파일러, 그랄 컴파일러
- AOT 컴파일러 : 그랄 컴파일러, JDK용 jaotc, 자바용 GNU 컴파일러(GCJ), 예흐켈시오르 JET

## 11.2 JIT 컴파일러

핫스팟과 OpenJ9 가상 머신은 자바 프로그램을 먼저 인터프리터로 해석해 실행한다. 그 후 **핫스팟 코드(핫 코드)가 발견되면 해당 코드를 네이티브 코드로 컴파일**하고 다양한 최적화를 적용해 실행 효율을 높인다. 이 작업을 수행하는 백엔드 컴파일러를 **JIT 컴파일러(적시 컴파일러)**라고 한다.

**핫스팟 코드(핫 코드)** : 자주 실행되는 메서드나 코드 블록

- 핫스팟 가상 머신이 인터프리터와 JIT 컴파일러를 함께 사용하는 이유는?
- 핫스팟 가상 머신이 여러 가지 JIT 컴파일러를 내장하는 이유는?
- 프로그램 실행 시 언제 인터프리터가 사용되고 언제 컴파일러가 사용되나?
- 네이티브 코드로 컴파일되는 프로그램 코드 종류와 그 방법은?
- JIT 컴파일러의 컴파일 과정과 컴파일 결과를 외부에서 볼 수 있는 방법은?

### 11.2.1 인터프리터와 컴파일러

모든 자바 가상 머신에 해당하지는 않지만, 주류 상용 가상 머신인 핫스팟과 OpenJ9은 모두 인터프리터와 컴파일러를 함께 사용한다.

인터프리터

- 컴파일 없이 곧바로 실행하여 프로그램을 빠르게 시작할 수 있다.
- 메모리가 부족한 환경에서 사용하여 메모리를 절약할 수 있다.
    - 일부 임베디드 시스템과 대부분의 자바 카드 제품에서는 인터프리터만 사용된다.

컴파일러

- 런타임 중에 코드를 네이티브 코드로 컴파일하여 실행 효율이 높다.

컴파일러가 가끔 특수한 상황에서 올바른 결과를 내지 못하는 최적화를 할 때가 있다. (새로운 클래스를 로드한 후 클래스 상속 구조가 바뀌는 등의) 이런 경우 최적화를 취소하고 다시 인터프리터에 실행을 맡길 수 있다.

핫스팟 가상 머신에 내장된 JIT 컴파일러

- 클라이언트 컴파일러 (C1 컴파일러)
- 서버 컴파일러 (C2 컴파일러)
- 그랄 컴파일러

클라이언트 컴파일러와 서버 컴파일러는 오래전부터 존재했고, 그랄 컴파일러는 JDK 10부터 등장했지만 별도 개발 중이다.

계층형 컴파일 모드가 등장하기 전 핫스팟 가상 머신에서는 일반적으로 인터프리터가 단 하나의 컴파일러와만 협력해 동작했다.

- 가상 머신을 클라이언트 모드로 실행 → C1 컴파일러
- 가상 머신을 서버 모드로 실행 → C2 컴파일러

하지만 지금은 자체 버전과 호스트 머신의 하드웨어 성능에 맞춰 실행 모드를 자동으로 선택한다.

### 계층형 컴파일

JIT 컴파일러가 바이트코드를 네이티브 코드로 컴파일하려면 시간이 걸리며, 일반적으로 최적화를 더 많이 할수록 컴파일도 오래 걸려 프로그램 시작이 늦어지지만, 최적화를 더 많이 한다면 운영 효율이 높아진다.

프로그램 시작 응답 속도와 운영 효율 사이에서 최상의 균형을 찾기 위해 핫스팟 가상 머신은 컴파일 서브시스템에 계층형 컴파일 기능을 추가했다.

계층형 컴파일 개념이 제안된 것은 훨씬 오래전이지만 JDK 6에 처음 제공됐으며, JDK 7에 서버 모드 가상 머신의 기본 컴파일 전략으로 승격됐다.

계층형 컴파일 단계

- **계층 0** : 인터프리터가 프로그램을 순수하게 해석 실행하며, 성능 모니터링은 하지 않는다.
- **계층 1** : 클라이언트 컴파일러를 사용하여 바이트코드를 네이티브 코드로 컴파일하고 실행한다. 이때 간단하고 안정적인 최적화만 수행하며, 성능 모니터링 기능은 하지 않는다.
- **계층 2** : 클라이언트 컴파일러를 사용하며, 메서드 및 반환 횟수 통계 등 몇 가지 성능 모니터링만 수행한다.
- **계층 3** : 여전히 클라이언트 컴파일러를 사용하며, 분기 점프와 가상 메서드 호출 버전 등 모든 성능 모니터링 정보를 수집한다.
- **계층 4** : 서버 컴파일러를 사용하며, 성능 모니터링 정보를 활용하여 더 오래 걸리는 최적화까지 수행한다. 이때 신뢰도가 낮은 공격적인 최적화를 수행하기도 한다.
    - 이 단계에서 최적화 취소가 일어날 수 있을 것 같다.

인터프리터, 클라이언트 컴파일러, 서버 컴파일러가 협력해 동작하면서 핫 코드가 여러 번 컴파일될 수 있다. 빠르게 컴파일 할 때는 클라이언트 컴파일러, 성능을 더 높여야 할 때는 서버 컴파일러를 사용한다.

서버 컴파일러가 매우 복잡한 최적화 알고리즘을 수행해야 할 때는 우선 클라이언트 컴파일러로 간단한 최적화를 해 놓고, 복잡한 최적화는 느긋하게 마무리하는 방식도 가능하다.

### 11.2.2 컴파일 대상과 촉발 조건

**핫 코드** : 런타임에 JIT 컴파일러가 컴파일하는 대상

핫 코드의 가장 대표적인 유형

1. 여러 번 호출되는 메서드
2. 여러 번 실행되는 순환문의 본문

1번은 가장 직관적인 유형이다. 메서드가 많이 호출될수록 메서드의 코드가 실행되는 횟수가 늘어나므로 핫 코드가 되는 것은 당연하다.

2번은 메서드가 적게 호출되거나 단 한 번만 호출되어도 핫 코드일 수 있다. 반복 횟수가 매우 많은 순환문의 본문 코드는 여러 번 실행되므로 핫 코드가 된다.

두 유형 모두에서 컴파일 대상은 개별 순환문의 본문이 아닌 **메서드 전체**다. 1번 유형은 메서드 호출에 의해 촉발되므로 메서드 전체가 컴파일 대상으로 되며, 2번 유형은 순환문 본문에 의해 촉발되지만 컴파일 대상은 메서드 전체다.

이때는 메서드의 실행 진입점(메서드의 첫 번째 바이트코드 명령어)이 살짝 달라지며, 컴파일 시 달라진 진입점의 바이트코드 인덱스 값을 컴파일러에 전달한다. 메서드가 실행되는 도중에, 즉 해당 메서드의 스택 프레임이 여전히 스택에 존재하는 상태에서 메서드가 치환되기 때문에 **온스택 치환**이라고 한다.

### 촉발 조건

- **여러 번**이라는 표현은 너무 주관적이다. 몇 번 실행되어야 여러 번이라고 할 수 있을까?
- 자바 가상 머신은 메서드나 특정 코드 블록이 실행되는 횟수를 어떻게 계산할까?

**핫스팟 코드 탐지 (핫스팟 탐지)** : 특정 코드 블록이 핫 코드인지, 그래서 JIT 컴파일을 촉발시켜야 하는지 판단하는 동작

사실 핫스팟을 탐지하기 위해 메서드가 몇 번이나 호출되었는지 알 필요는 없다.

- **샘플 기반 핫스팟 코드 탐지** : 각 스레드의 호출 스택 상단을 샘플링(주기적으로 확인)하여 특정 메서드 또는 메서드의 일부가 자주 발견되면 해당 메서드를 **핫 메서드**로 간주한다. 구현하기 쉽고 효율적이며 메서드 호출 관계를 쉽게 파악할 수 있는 방식이다. (호출 스택을 훑으면 됨) 하지만 메서드의 핫한 정도를 정확하게 알기는 어렵고 스레드 블로킹 등의 외부 요인이 핫스팟 탐지를 방해하기 쉽다.
    - 일정 기간 동안 수집한 스택 트레이스를 기반으로, 각 메서드의 등장 빈도수로 탐지한다.
- **카운터 기반 핫스팟 코드 탐지** : 각 메서드와 코드 블록에 대한 카운터를 설정하여 개별 실행 횟수를 기록한다. 실행 횟수가 설정값을 초과하면 **핫 메서드**로 간주한다. 메서드 각각에 대한 카운터를 설정하고 유지해야 해서 구현하기가 더 번거롭고, 메서드 호출 관계도 직접 얻을 수 없다. 반면 더 정확하고 엄격한 결과를 얻을 수 있다.
    - 설정값 - 클라이언트 모드: 1500회, 서버 모드: 10,000회

### 11.2.3 컴파일 과정

기본적으로 JIT 컴파일은 백그라운드에서 별도 스레드가 진행하며, 컴파일이 완료될 때까지는 인터프리터가 프로그램 실행을 이어 간다. 설정을 통해 백그라운드 컴파일을 비활성화할 수 있으며, 비활성화 상태에서 JIT 컴파일을 요청한 스레드는 컴파일이 완료될 때까지 일시 정지 상태로 대기했다가, 완료되면 컴파일러가 생성한 네이티브 코드를 실행한다.

## 11.3 AOT 컴파일러

### 11.3.1 AOT 컴파일의 장점과 단점

### 장점

AOT 컴파일러 관련 연구는 크게 두 가지 형태로 나뉜다.

- 프로그램이 실행 되기 전에 프로그램 코드를 네이티브 코드로 컴파일 하는 형태 (기존 C·C++ 컴파일러와 비슷함)
- 원래 JIT 컴파일러가 런타임에 수행해야 하는 작업을 미리 수행해 캐시에 저장해 두고 다음번 실행 시 사용하는 형태
