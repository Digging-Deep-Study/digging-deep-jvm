# 7장 클래스 로딩 메커니즘

이전 장에서 클래스 파일 저장 형식을 알아보았고, 클래스 파일에 서술된 정보를 가상 머신이 이용하려면 먼저 로드해야 한다. 가상 머신이 클래스 파일을 로드하는 방법과 그 정보를 가상 머신 안에서 활용하는 방법을 알아보자.

자바 가상 머신은 클래스를 설명하는 데이터를 클래스 파일로부터 메모리로 읽어 들이고 그 데이터를 검증, 변환, 초기화하고 나서 최종적으로 가상 머신이 곧바로 사용할 수 있는 자바 타입을 생성한다. 이 과정을 가상 머신의 클래스 로딩 메커니즘이라고 한다.

컴파일 시 링크까지 해야 하는 언어들과 달리 자바에서는 **클래스 로딩**, **링킹**, **초기화**가 모두 **프로그램 실행** 중에 이루어진다. 그래서 자바는 AOT 컴파일에 제약이 생기고 클래스 로딩을 거치느라 실행 성능이 살짝 떨어진다. 하지만 이는 자바 애플리케이션의 높은 확장성과 유연성을 가능하게 하는 이점으로도 작용한다.

자바가 동적 확장 언어 기능을 제공할 수 있는 것은 런타임에 이루어지는 동적 로딩과 동적 링킹 덕분이다. 예를 들어 애플리케이션을 인터페이스 중심으로 작성해 두면 실제 구현 클래스를 결정하는 일은 실행 시까지 미룰 수 있다. 또한 클래스 로더를 활용하면 실행 중인 프로그램의 코드 일부를 네트워크를 통해 바이너리 스트림으로 읽어올 수 있다.

# 7.2 클래스 로딩 시점

- 로딩, 검증, 준비, 초기화, 언로딩은 반드시 순서대로 진행해야 한다.
- 반면 해석 단계는 때에 따라서 초기화 후에 시작할 수 있다.
    - 자바의 **런타임 바인딩**(동적 바인딩 또는 늦은 바인딩)을 지원하기 위해서다.
- 단계별 순서의 기준은 **진행**이나 **완료** 시점이 아닌 **시작 시점**이다.
    - 가끔 여러 단계가 병렬로 진행되기도 한다.

클래스 로딩의 첫 단계인 로딩은 자바 가상 머신 명세에 정확히 어떤 상황에서 시작해야 하는지 명시하지 않았기 때문에 가상 머신 구현자가 자유롭게 선택할 수 있다.

반면 초기화 단계는 즉시 시작되어야 하는 상황 6가지를 엄격히 규정했다.

**(타입에 대한 능동 참조 : 타입 초기화를 촉발하는 참조 방식)**

1. 바이트코드 명령어인 **new**, **getstatic**, **putstatic**, **invokestatic**을 만났을 때 해당 타입이 아직 초기화되어 있지 않다면 초기화를 촉발한다. 자바 코드에서 이 명령어들을 생성하는 일반적인 시나리오는 다음과 같다.
    - new 키워드로 객체의 인스턴스 생성
    - 타입의 정적 필드를 읽거나 설정
        - final로 지정된 정적 필드는 컴파일 타임에 상수 풀에 채워지므로 제외
    - 타입의 정적 메서드 호출
2. Class 클래스나 java.lang.reflect 패키지 등 표준 클래스 라이브러리에서 제공하는 리플렉션 메서드를 사용할 때 해당 타입이 아직 초기화되어 있지 않다면 초기화를 촉발한다.
3. 클래스를 초기화할 때 상위 클래스가 초기화되어 있지 않다면 상위 클래스 초기화를 촉발한다.
    - 인터페이스 초기화에는 상위 인터페이스 초기화가 필요 없다.
4. 가상 머신은 구동 직후 사용자가 지정한 메인 타입(main() 메서드를 포함하는 클래스나 인터페이스)을 찾아 실행한다. 이때 메인 타입의 초기화를 먼저 시작한다.
5. REF_getStatic, REF_putStatic, REF_invokeStatic, REF_newInvokeSpecial 타입 메서드 핸들을 해석해 얻은 java.lang.invoke.MethodHandle 인스턴스를 호출할 때 해당하는 클래스가 초기화되어 있지 않았다면 초기화를 촉발한다.
6. 인터페이스에 디폴트 메서드를 정의했다면, 해당 인터페이스를 직간접적으로 구현한 클래스가 초기화될 때 인터페이스부터 초기화한다.

**수동 참조 : 타입 초기화를 촉발하지 않는 그 외의 모든 참조 방식**

- 상위 클래스에 정의된 필드를 하위 클래스를 통해 참조하는 경우
    - 정적 필드를 참조할 때는 필드를 직접 정의한 클래스만 초기화된다.
- 배열 정의에서 클래스를 참조하는 경우
    - 클래스 초기화 단계가 촉발되지 않고 클래스 타입의 배열 초기화 단계를 촉발한다.
- 클래스의 정적 필드가 상수일 때
    - 컴파일 과정에서 상수 전파 최적화가 이루어져 클래스의 상수 풀에 직접 저장되어 정적 필드를 참조하는 코드는 상수 풀을 참조하도록 변경된다.

# 7.3 클래스 로딩 처리 과정

## 7.3.1 로딩

클래스 로딩의 전체 과정 중 한 단계를 말한다.

자바 가상 머신이 로딩 단계에서 수행해야 하는 작업

1. 완전한 이름을 보고 해당 클래스를 정의하는 바이너리 바이트 스트림을 가져온다.
2. 바이트 스트림으로 표현된 정적인 저장 구조를 메서드 영역에서 사용하는 런타임 데이터 구조로 변환된다.
3. 로딩 대상 클래스를 표현하는 java.lang.Class 객체를 힙 메모리에 생성한다. 이 Class 객체는 애플리케이션이 메서드 영역에 저장된 타입 데이터를 활용할 수 있게 하는 통로가 된다.

1번 작업에서 바이트 스트림을 가져오는 클래스 파일의 위치나 읽어 오는 방법을 구체적으로 명시하지 않아 로딩 단계에서 개방적으로 작업을 수행할 수 있게 되어 많은 기술이 만들어졌다.

- ZIP 압축 파일로부터 로딩 : 초기부터 흔히 쓰이던 방식으로 이후 JAR, EAR, WAR 형식의 기초가 되었다.
- 네트워크로부터 로딩 : 대표적인 응용 예로 웹 애플릿이 있다.
- 런타임에 동적으로 생성 : 대표적인 응용 예는 동적 프록시 기술이다. 실제로 java.lang.reflect.Proxy의 ProxyGenerator.generateProxyClass() 메서드는 지정한 인터페이스에 대해 **$Proxy** 형태의 프록시 클래스에 해당하는 바이너리 바이트 스트림을 생성해 준다.
- 다른 파일로부터 생성 : 대표적으로 JSP 애플리케이션은 클래스 파일을 JSP 파일로부터 생성한다.
- 데이터베이스로부터 로딩 : 비교적 흔치 않지만, SAP 넷위버(Netweaver) 같은 일부 미들웨어는 프로그램을 데이터베이스 안에 설치한 후 클러스터에 배포하는 방식을 제공한다.
- 암호화된 파일로부터 로딩 : 클래스 파일 디컴파일을 막기 위해 흔히 쓰이는 보호 조치다. 로딩 과정에서 클래스 파일을 해독하여 스누핑 공격으로부터 프로그램 로직을 보호한다.

로딩 단계가 끝나면 바이너리 바이트 스트림은 자바 가상 머신이 정의한 형식에 맞게 메서드 영역에 저장된다. 타입 정보를 메서드 영역에 올바르게 저장한 뒤 해당 java.lang.Class 객체를 자바 힙에 초기화한다. Class 객체는 애플리케이션에서 메서드 영역 안의 타입 데이터에 접근하기 위한 통로 역할을 한다.

## 7.3.2 검증

링킹 과정 중 첫 번째 단계이며, 검증의 목적은 두 가지다.

1. 클래스 파일의 바이트 스트림에 담긴 정보가 **자바 가상 머신 명세**에서 규정한 모든 제약을 만족하는지 확인한다.
2. 이 정보를 코드로 변환해 실행했을 때 자바 가상 머신 자체의 보안을 위협하지 않는지 확인한다.

클래스 파일은 자바 소스 코드로부터 컴파일하지 않아도 바이너리 편집기로도 만들 수 있다. 따라서 순수한 자바 코드에서는 할 수 없는 일이라도 바이트코드 수준에서는 가능할 수 있다. 그래서 자바 가상 머신이 입력 바이트 스트림을 검증하지 않는다면 오류가 있거나 악의적으로 작성된 바이트코드 스트림이 로드되어 시스템 전체를 해칠 수 있다.

### 검증 단계

1. 파일 형식 검증
2. 메타데이터 검증
3. 바이트코드 검증
4. 심벌 참조 검증

### 1. 파일 형식 검증

바이트 스트림이 클래스 파일 형식에 부합하고 현재 버전의 가상 머신에서 처리될 수 있는지 확인한다.

- 매직 넘버인 0xCAFEBABE로 시작하는가?
- 메이저 버전과 마이너 버전 번호가 현재 자바 가상 머신이 허용하는 범위에 속하는가?
    
    …
    

위 내용말고도 실제 검증하는 항목은 훨씬 많다.

**주된 목적 :** 입력 바이트 스트림이 올바르게 해석되어 메서드 영역에 저장되어 있는지, 파일 형태가 자바 타입 정보 설명에 대한 요구 사항을 준수하는지 확인하는 것이다.

이 단계의 검증은 바이너리 바이트 스트림을 대상으로 이루어지며, 검증을 통과하면 바이트 스트림이 메서드 영역에 저장된다.

### 2. 메타데이터 검증

바이트코드로 설명된 정보의 의미를 분석하여 서술된 정보가 자바 언어 명세의 요구 사항을 충족하는지 확인한다.

- 상위 클래스가 있는가?
- 상위 클래스가 상속을 허용하는가?
    
    …
    

**주된 목적 :** 클래스의 메타데이터 정보에 대한 의미론적 검증을 수행하여 자바 언어 명세와 일치하지 않는 메타데이터가 섞여 있지 않은지 확인하는 것이다.

### 3. 바이트코드 검증

전체 검증 과정 중 가장 복잡하다.

**주된 목적 :** 데이터 흐름과 제어 흐름을 분석하여 프로그램의 의미가 적법하고 논리적인지 확인하는 것이다.

메타데이터 검증에서 데이터 타입 관련 검증을 마친 후, 이번 단계에서 클래스의 메서드 본문(클래스 파일의 Code 속성)을 분석한다. 메서드가 런타임에 가상 머신의 보안을 위협하는 동작을 하지 않는지 확인하는 것이다.

메서드 본문이 바이트코드 검증을 통과하지 못하는 타입은 당연히 문제가 되지만, 검증을 통과했다고 해서 100% 안전하다는 보장은 없다. 최대한 많은 사항을 철저히 검사하더라도 한계는 있다.

게다가 데이터 흐름 분석과 제어 흐름 분석은 굉장히 복잡하기 때문에 바이트코드 검증 단계는 자칫 너무 길어질 수 있다. JDK 6 이후로는 이 문제를 피하기 위해 가능한 한 많은 유효성 검사를 javac 컴파일러로 옮겼다.

### 4. 심벌 참조 검증

가상 머신이 심벌 참조를 직접 참조로 변환할 때 수행된다. 이 변환은 링킹의 세 번째 단계인 해석 단계에서 일어나며, 해당 클래스 자체(상수 풀의 다양한 심벌 참조)를 제외한 모든 정보를 확인한다. 쉽게 말하면 현재 클래스가 참조하는 특정 외부 클래스, 메서드, 필드 등 자원들에 접근 권한이 있는지 확인한다.

- 심벌 참조에서 문자열로 기술된 완전한 이름에 해당하는 클래스를 찾을 수 있는가?
- 심벌 참조가 가리키는 클래스, 필드, 메서드의 접근 지정자(private…)가 현재 클래스의 접근을 허용하는가?
    
    …
    

**주된 목적** : 해석을 제대로 수행할 수 있는지 확인한다. 검증을 통과하지 못하면 자바 가상 머신이 IncompatibleClassChangeError의 하위 예외를 던진다.

검증 단계는 매우 중요하지만 필수는 아니다. 그래서 애플리케이션에서 실행하는 모든 코드를 신뢰할 수 있다면 프로덕션 환경에서 실행할 때는 검증을 건너뛰기도 한다. 검증을 생략하면 클래스 로딩 시간이 제법 단축된다.

## 7.3.3 준비

클래스 변수(정적 변수)를 메모리에 할당하고 초기값을 설정하는 단계다.

- 인스턴스 변수가 아닌 클래스 변수만 할당된다.
- 초기값은 리터럴이 아닌 타입의 초기값이다. (int → 0)

## 7.3.4 해석

자바 가상 머신이 상수 풀의 심벌 참조를 직접 참조로 대체하는 과정이다.

- 심벌 참조 : 몇 가지 심벌로 참조 대상을 설명한다. 심벌은 대상을 명확하게 지칭하는 데 이용될 수 있는 모든 형태의 리터럴이 될 수 있다.
- 직접 참조 : 포인터, 상대적 위치 또는 대상의 위치를 간접적으로 가리키는 핸들이다. 직접 참조는 가상 머신에 구현된 메모리 레이아웃과 밀접하게 연관되어 똑같은 심벌 참조로부터 변환했더라도 가상 머신에 따라 달라지는 게 보통이다.

해석은 주로 7가지 타입의 심벌 참조에 대해 수행한다.

- **클래스**
- **인터페이스**
- **필드**
- **클래스 메서드**
- 인터페이스 메서드
- 메서드 타입
- 메서드 핸들

## 7.3.5 초기화

클래스 로딩의 마지막 단계다. 사용자 정의 클래스 로더를 이용하여 로딩의 일부 단계에 관여할 수 있지만, 대부분의 작업은 온전히 자바 가상 머신이 통제한다.

초기화 단계에 들어서면 자바 가상 머신이 드디어 사용자 클래스에 작성된 자바 코드를 실행하기 시작한다. 준비 단계에서 모든 변수에 타입의 초기값으로 할당했지만 초기화 단계에서는 코드에 기술한 대로 초기화한다.

# 7.4 클래스 로더

자바 가상 머신 설계진은 필요한 클래스를 얻는 방법을 애플리케이션이 정할 수 있기를 원했다. 그래서 클래스 로딩 단계 중 **완전한 이름을 보고 해당 클래스를 정의하는 바이너리 바이트 스트림 가져오기**를 가상 머신 외부에서 수행하도록 했다. 이 역할을 맡은 코드를 **클래스 로더**라고 한다.

## 7.4.1 클래스와 클래스 로더

클래스 로더는 클래스를 로딩하는 일 뿐만 아니라 특정 클래스가 자바 가상 머신에서 유일한지 판단하는 일도 한다. 어떤 두 클래스가 동치 관계(동등)인지는 두 클래스 모두 같은 클래스 로더에 의해 로드됐을 때만 의미가 있다. 서로 다른 클래스 로더로 읽어 들였다면, 비록 같은 가상 머신이고 같은 클래스 파일로부터 로드했더라도 다른 클래스로 인식된다.

## 7.4.2 부모 위임 모델

자바 가상 머신 관점에서 클래스 로더의 종류는 두 가지 뿐이다.

- **자바 가상 머신 자체의 일부인 부트스트랩 클래스 로더** : 핫스팟 가상 머신에서는 C++로 구현했다.
- **그 외 모든 클래스 로더** : 추상 클래스인 java.lang.ClassLoader를 상속하여 자바로 구현하며, 가상 머신 외부에 독립적으로 존재한다.

### 3계층 클래스 로더

- **부트스트랩 클래스 로더** : JAVA_HOME/lib 디렉토리나 -Xbootclasspath 매개 변수로 지정한 경로에 위치한 파일들과 자바 가상 머신이 클래스 라이브러리로 인식하는 파일들을 로드하는 일을 책임진다. 부트스트랩 클래스 로더는 자바 프로그램에서 직접 참조할 수 없다. 커스텀 클래스 로더 작성 시 로딩을 부트스트랩 클래스 로더에 위임하고자 할 때는 참조 대신 null을 사용한다.
- **확장 클래스 로더** : sum.misc.Launcher$ExtClassLoader를 말하며 자바로 구현되었다. JAVA_HOME/lib/ext 디렉토리 또는 java.ext.dirs 시스템 변수로 지정한 경로의 클래스 라이브러리들을 로드하는 역할을 한다. 자바 시스템의 클래스 라이브러리를 확장하는 메커니즘이다. 확장 클래스 로더는 자바 코드로 구현되었기 때문에 개발자가 애플리케이션 안에서 직접 사용할 수 있다.
- 애플리케이션 클래스 로더 : sun.misc.Launcher$AppClassLoader를 말한다. ClassLoader 클래스의 getSystemCLassLoader() 메서드가 반환하는 클래스 로더라는 의미에서 시스템 클래스 로더라고도 한다. 클래스 패스상의 클래스 라이브러리들을 로드하는 역할을 하며, 개발자가 자바 코드에서 직접 사용할 수 있다. 애플리케이션에서 클래스 로더를 따로 만들어 이용하지 않는 경우 이 로더가 기본 클래스 로더가 된다.
