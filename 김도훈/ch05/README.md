# 5장 최적화 사례 분석 및 실전

### 5.2.1 대용량 메모리 기기 대상 배포 전략

> 하드웨어 시스템을 스펙업하여 자바 힙 크기를 12GB로 설정했다. 하지만 서버 실행 효율이 기대에 한참 못 미치고, 웹 서비스가 장시간 응답하지 않는 일이 자주 벌어졌다.

응답이 지연되는 원인은 가비지 컬렉션이었고, 서버 모드로 실행한 핫스팟 가상 머신의 기본 설정은 패러렐 컬렉터였다. 패러렐 컬렉터는 일시 정지 시간보다는 처리량에 중점을 둔 컬렉터였기 때문에 12GB에 달하는 힙 메모리를 전체 GC하기 위해 최장 14초까지 일시 정지했던 것이다.
> 

자바 가상 머신의 모든 가비지 컬렉터는 특정한 애플리케이션 타입과 동작 시나리오를 목표로 설계되었다. 따라서 애플리케이션을 시나리오에 알맞게 설정하여 배포한다면 좋은 효과를 얻을 수 있다.

**현재 대용량 메모리를 갖춘 하드웨어에 단일 자바 애플리케이션을 배포하는 주된 방식**

1. 가상 머신 인스턴스 하나가 거대한 자바 힙 메모리를 관리한다.
2. 가상 머신 여러 개를 동시에 띄워 논리적인 클러스터를 구성한다.

**첫 번째 배포 방식**

위 사례는 사용자와 상호 작용이 많고 일시 정지 시간에 민감하고 대용량 메모리를 갖추고 있어서 셰넌도어나 ZGC처럼 지연 시간 통제를 목표로 하는 가비지 컬렉터를 이용하면 이 문제를 해결할 수 있다.

**두 번째 배포 방식** 

패러렐 컬렉터로 대량의 힙을 성공적으로 관리하는 사례도 많다.

- 전체 GC 빈도를 가능한 낮게, 적어도 사용자가 이용하는 도중에는 일어나지 않게 제어해야 한다.
    - ex) 전체 GC 없이 하루 이상 가동될 수 있도록 만들어 두고, 매일 새벽에 전체 GC를 수행하거나 애플리케이션 서버를 자동으로 재시작하도록 스케줄링한다.

### 첫 번째 방식으로 배포할 때 고려해야 할 점

- 힙 메모리의 거대 블록들을 수거하느라 발생되는 긴 일시 정지
    - G1 컬렉터의 등장과 점진적 회복이 활발히 활용되고, ZGC와 셰넌도어까지 상당히 발전되어 개선됨
- 64비트 자바 가상 머신에서는 대용량 메모리를 사용할 수 있다.
    - 하지만 압축 포인터나 프로세서 캐시 라인 용량 같은 요인 때문에 64비트 가상 머신의 성능은 일반적으로 동일 버전의 32비트 가상 머신보다 조금씩 느리다.
- 애플리케이션이 충분히 안정적이어야 한다.
    - 대규모 단일 애플리케이션에서 힙 메모리가 오버플로되면 힙 덤프 스냅숏을 생성하기가 거의 불가능하기 때문에 JMC와 같이 프로덕션 환경에서 수행할 수 있는 운영 도구를 활용해야 할 수 있다.
- 같은 애플리케이션이라도 32비트 가상 머신보다 64비트 가상 머신에서 메모리를 많이 사용한다.
    - 포인터 확장, 데이터 타입 정렬, 패딩 등의 요인 때문이다. 압축 포인터를 이용하면 이런 요인이 일으키는 메모리 추가 소비를 줄일 수 있지만, 약간의 성능은 떨어진다.

위와 같은 문제들로 인해 두 번째 배포 방식을 많이 채택하기도 한다. 즉, 가상 머신 여러 개로 논리 클러스터를 구축해 하드웨어 자원을 활용하는 것이다.

- 예를 들어 같은 물리 머신에서 애플리케이션 서버 프로세스를 여러 개 띄우고 각각 서로 다른 포트로 할당한 후, 앞단에 로드밸런싱을 둔 리버스 프록시 방식으로 요청을 분배하는 것이다.

### 두 번째 방식으로 배포할 때 고려해야 할 점

- 노드들이 전역 자원을 놓고 경합한다.
    - 가장 흔한 예는 디스크가 있고, 각 노드가 동시에 디스크를 읽으려고 하면 I/O 예외가 일어나기 쉽다. 특히 동시 쓰기 연산이 문제를 잘 일으킨다.
- 커넥션 풀과 같은 자원 풀을 효율적으로 활용하기 어렵다.
    - 자원 풀은 일반적으로 노드별로 따로 만들어 관리하기 때문에 다른 노드들의 풀은 여유로운데, 특정 노드의 풀만 가득 찰 수 있다. 중앙화된 JNDI로 해결할 수 있지만 다소 복잡하고 성능 비용이 추가로 발생한다.
- 클러스터 노드로 32비트 가상 머신을 이용한다면 노드별 메모리는 여전히 32비트로 제한된다.
- 해시 맵이나 키-값 캐시 등의 로컬 캐시를 많이 이용하는 애플리케이션이라면 논리 클러스터 방식에는 상당량의 메모리가 낭비된다. 캐시를 노드당 하나씩 두기 때문이다. 이런 경우라면 로컬 캐시 대신 중앙화된 캐시를 활용하는 방법도 고려해볼 수 있다.

### 5.2.2 클러스터 간 동기화로 인한 메모리 오버플로

> 서버 클러스터링을 구성한 후 공유 데이터를 DB로 관리했지만 성능에 미치는 영향이 커서 JBossCache로 글로벌 캐시를 구축했다. 서비스가 원활하게 운영되었지만 시간이 지나 메모리 오버플로가 가끔 발생하기 시작했다.

특정 상황에서 네트워크가 데이터 전송량을 다 처리하지 못하게 되면 재전송된 데이터가 메모리에 계속 쌓이다가 오버플로가 발생한 것이었다.
> 

위 사례처럼 클러스터 전체에서 공유해야 하는 데이터를 JBossCache 같은 분산 클러스터 캐시를 이용해 동기화하면 네트워크 통신이 자주 일어날 수 있다. 다행히 로컬 메모리에 복사본을 두기 때문에 읽기 작업에는 자원을 많이 소비하지 않지만, 쓰기는 네트워크 동기화 오버헤드를 일으키므로 너무 빈번하게 해서는 안 된다.

### 5.2.4 시스템을 느려지게 하는 외부 명령어

> 시스템에 동시성 스트레스 테스트를 수행하자 응답 속도가 지나치게 느려졌다. 확인해보니 프로세서 이용률은 매우 높았지만, 프로세서 자원 대부분을 소비하는 주체는 이 시스템이 아니었다. 보통 사용자 애플리케이션이 프로세서를 많이 점유하는 게 일반적이다.

원인은 애플리케이션에서 외부 쉘 스크립트를 실행하도록 작성된 것이다. 쉘 스크립트는 자바의 `Runtime.getRuntime().exec()` 로 실행했으며, 이 방식으로는 실행한다는 목적은 이룰 수 있지만 자원을 매우 많이 소비한다.
> 

외부 명령 자체는 빠르게 실행되더라도 빈번히 호출되는 경우라면 프로세스 생성 비용을 간과해서는 안 된다. 프로세서 자원뿐 아니라 메모리 부담 역시 크게 늘어난다.

쉘 스크립트 실행 코드를 제거한 후 자바 API로 요청하도록 변경했다.

### 5.2.6 부적절한 데이터 구조로 인한 메모리 과소비

> 파뉴+CMS 컬렉터 조합을 이용했고 마이너 GC 시간은 보통 30ms 이내였기에 해당 애플리케이션을 이용하는 외부 서비스들에 아무런 문제가 없었다. 하지만 데이터를 분석하기 위해 10분 단위로 80MB 크기의 파일을 메모리로 읽어 들여야 했는데, 이때 100만 개 이상의     `HashMap<Long, Long>` 객체를 만들어내며 마이너 GC가 100만 개가 넘는 객체를 검사하느라 일시 정지가 500ms로 늘어났다.
> 

근본적인 원인은 `HashMap<Long, Long>` 이다. 이 구조는 공간을 효율적으로 활용하지 못해서 위 사례처럼 데이터가 많을 때는 적합하지 않다.

`HashMap`의 공간 효율성을 계산해보자면,

- `HashMap<Long, Long>` 구조에서 키와 값에 해당하는 long 정수 2개만이 사용자에게 의미 있는 데이터다. → 총 16바이트
- 이 두 long 데이터 각각은 java.lang.Long 객체로 감싸지며, Long 객체는 8바이트의 마크 워드, 8바이트의 클래스 포인터, 데이터를 담기 위한 8바이트의 long 변수로 구성된다 → 총 24바이트

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/0a08179c-6898-4f98-8b89-2a2ddd15c8b3/e34b7de0-515c-4488-a3a4-0c7240ab3e58/image.png)

- Long 객체는 Map.Entry에 저장되며, Map.Entry는 16바이트의 객체 헤더, 8바이트의 next 필드, 4바이트의 해시 필드로 구성된다. 여기에 총 32바이트 크기로 맞추기 위한 정렬용 패딩 4바이트도 추가된다. → 총 32바이트
- HashMap에서는 8바이트 참조를 통해 Map.Entry를 가리킨다. → 8바이트

결과적으로 long 정수 두 개를 담는 데 쓰이는 실제 메모리는

Long(24바이트) * 2 + Entry(32바이트) + HashMap 안의 참조(8바이트)까지 해서 총 88바이트다.

메모리 사용량 중 유효 데이터의 비율은 겨우 18%로 정말 낮은 효율이라 할 수 있다.

자료구조를 상황에 따라 적재적소에 사용할 수 있는 역량 필요.
