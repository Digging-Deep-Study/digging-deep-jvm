# 5장 최적화 사례 분석 및 실전
> 가상 머신 문제 해결과 최적화 실제 사례

## 사례 분석
- 설계와 개발 단계가 아닌 애플리케이션 배포 수준에서의 문제 해결에 집중한다.
- 기존 하드웨어와 소프트웨어를 유지한 채 배포와 설정 전략을 조율하여 문제를 풀거나 완화하는 방법을 다룬다.

### 1 대용량 메모리 기기 대상 배포 전략
문제
- 64비트 환경에 맞춰 자바 힙을 12GB로 크게 설정했더니 GC 일시 정지 시간이 길어짐(최대 14초).
- 웹 페이지 직렬화 과정에서 거대 객체가 구세대에 계속 쌓여, 몇 분마다 10초씩 서버가 멈추는 사태 발생.
- 기존 32비트 환경(힙 1.5GB)에서는 다소 느렸지만 수초 이상 응답이 지연되진 않았음. 하드웨어 업그레이드 후 응답성이 오히려 악화됨.

원인
- 패러렐 컬렉터는 일시 정지 시간보다는 처리량에 중점을 둔 컬렉터로, 거대한 힙을 정리할 때 장시간 일시 정지가 발생함.
- 프로그램 특성상 거대 객체가 자주 생성되어 바로 구세대로 넘어가, 힙이 급격하게 가득 찼음.
- 힙 메모리를 너무 크게 잡아서 회수하고 재활용하는 데 너무 오래 걸림.

해결
- 첫 번째 방식: 가상 머신 인스턴스 하나가 거대한 자바 힙 메모리를 관리한다.
  - 셰넌도어나 ZGC처럼 지연 시간 통제를 목표로 하는 GC를 사용.


- 두 번째 방식: 가상 머신 여러 개를 동시에 띄워 논리적인 클러스터를 구성한다.
  - 예를 들어 같은 물리 머신에 프로세스 여러 개를 띄우고 각각 포트를 다르게 할당. 앞단에 부하 분산기로 트래픽 분산.

- 최종 선택한 배포 방식: 32비트 가상 머신 5개로 논리 클러스터를 구축하여 메모리를 프로세스당 2GB씩 할당함.(총 10GB 활용)
  - GC를 CMS로 변경해서 일시 정지 시간을 더 줄이고, 결과적으로 하드웨어 업그레이드 전보다 응답 속도가 훨씬 개선됨.

### 2 클러스터 간 동기화로 인한 메모리 오버플로
문제
- 8GB 메모리를 갖춘 HP 미니컴퓨터 2대에 웹로직 9.2를 3개씩 구동(총 6노드의 선호도 클러스터)하던 중, DB로 관리되고 있는 공유 데이터를 자주 읽고 쓰면서 경합 이슈 발생.
- JBossCache로 글로벌 캐시를 구축해서 사용함. 초기에는 문제가 없었는데 이후 메모리 오버플로가 발생하기 시작함.
- 힙 덤프 분석 결과, 수많은 `org.jgroups.protocols.pbcast.NAKNAK` 객체가 발견됨.

원인
- 보안용 글로벌 필터가 모든 노드에 마지막 작업 시간을 동기화하는 과정에서 네트워크 요청이 과도하게 발생.
- 특정 상황에서 네트워크가 데이터 전송량을 다 처리하지 못하면 재전송된 데이터가 메모리에 계속 쌓이고 오버플로를 일으킴.
- JBossCache의 결함 및 잦은 쓰기 작업(동기화) 요청이 복합적으로 문제를 유발.

해결
- JBossCache 버전 업그레이드
- 쓰기 작업(동기화)을 최소화할 수 있도록 데이터 동기화 설계를 다시 검토

### 3 힙 메모리 부족으로 인한 오버플로 오류
문제
- 브라우저-서버 기반 온라인 시험 시스템에서 서버 푸시(CometD + Jetty) 기술을 활용하여 실시간 시험 데이터를 전송
- 인텔 코어 i5, 메모리 4GB, 32비트 윈도우 환경에서 프로세스 최대 메모리는 2GB로 제한되는데, 이 중 1.6GB를 자바 힙에 할당함.
- 테스트 중 서버에서 메모리 오버플로가 종종 발생함.

원인
- 시스템 로그에서 다이렉트 메모리가 부족해서 예외가 발생했음을 알 수 있음
- 다이렉트 메모리는 힙에 속하지 않아서 힙(1.6GB) 외에 남은 0.4GB에서 할당해야 하는데 CometD 1.1.1 프레임워크는 다이렉트 메모리를 이용하는 NIO 연산을 매우 많이 수행함.
- 다이렉트 메모리는 가비지 컬렉션 대상은 맞지만, 힙에 속하지 않기 때문에 메모리 공간이 부족해도 가비지 컬렉터에 능동적으로 알리지 못함. 힙의 구세대가 모두 차서 전체 GC가 수행되기만을 기다려야 함.
- 물리 메모리 용량이 적은 시스템이나 32비트 애플리케이션에서는 자바 힙과 메서드 영역 외에 다음 영역들도 가용 메모리에서 상당한 비중을 차지한다. 그 결과 메모리 총합이 운영 체제가 프로세스에 허용하는 한계를 넘어서는 경우가 많다.
  - 다이렉트 메모리
  - 스레드 스택
  - 소켓 버퍼 영역
  - JNI 코드
  - 가상 머신과 가비지 컬렉터

해결
- 서버 푸시 방식으로 다이렉트 메모리를 자주 사용하는 애플리케이션이라면, 운영 체제와 JVM의 메모리 제한을 명확히 이해하고 힙과 다이렉트 메모리를 적절하게 분배해야 한다.

### 4 시스템을 느려지게 하는 외부 명령어

### 5 서버 가상 머신 프로세스 비정상 종료

### 6 부적절한 데이터 구조로 인한 메모리 과소비

### 7 윈도우 가상 메모리로 인한 긴 일시 정지

### 8 안전 지점으로 인한 긴 일시 정지
