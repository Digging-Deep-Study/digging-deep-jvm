# 11 백엔드 컴파일과 최적화

## 마치며
- 두 가지 주요 백엔드 컴파일러인 JIT와 AOT 컴파일러
  - AOT 컴파일러가 다시 등장한 이유와 장단점
  - JIT 컴파일러 관련. 핫스팟 탐지 방법, 컴파일 촉발 조건, 가상 머신 외부에서 JIT 컴파일과 그 결과를 관찰하고 분석하는 방법
  - 보편적인 컴파일러 최적화 기법
- 자바 컴파일러의 깊이 있는 이해를 통해 실무에서 컴파일러가 최적화하기 유리한 코드를 작성할 수 있다.

## 들어가며
백엔드 컴파일 과정
- 컴파일러가 클래스 파일을 로컬 환경(하드웨어 명령어 집합, 운영체제)에 맞는 네이티브 코드로 변환하는 과정

이번 장에서는 따로 명시하지 않는 한
- JIT 컴파일러
  - 핫스팟 가상 머신의 내장 컴파일러
- 가상 머신
  - 핫스팟 가상 머신

## JIT 컴파일러
핫스팟/OpenJ9
- 자바 프로그램을 먼저 인터프리터로 해석해 실행한다. 그런 다음 아주 자주 실행되는 메서드나 코드 블록이 발견되면 해당 코드를 네이티브 코드로 컴파일하고 다양한 최적화를 적용해 실행 효율을 높인다.

핫스팟 코드 또는 핫코드
- 아주 자주 실행되는 메서드나 코드 블록

JIT 컴파일러(적시 컴파일러)
- 런타임에 핫 코드가 발견되면 해당 코드를 네이티브 코드로 컴파일하고 다양한 최적화를 적용해 실행 효율을 높이는 작업을 수행하는 백엔드 컴파일러

### 인터프리터와 컴파일러
- 현재 주류 상용 가상 머신인 핫스팟과 OpenJ9은 인터프리터와 컴파일러를 함께 사용한다.
- 프로그램을 빠르게 시작해야 할 때는 인터프리터가 먼저 나서서 컴파일 없이 곧바로 실행할 수 있다.
- 프로그램이 시작되고 시간이 흐를수록 컴파일러의 역할이 커진다. 점점 더 많은 코드를 네이티브 코드로 컴파일해 실행을 높인다.
- 핫스팟 가상 머신에는 JIT 컴파일러가 2개 또는 3개 내장되어 있다.
  - C1 클라이언트 컴파일러
  - C2 서버 컴파일러
  - 그랄 컴파일러

계층형 컴파일 모드가 등장하기 전
- 핫스팟 가상 머신에서는 일반적으로 인터프리터가 단 하나의 컴파일러와만 협력해 동작했다.
- 가상 머신을 클라이언트 모드로 실행하면 C1(클라이언트 컴파일러)만 쓰이고,
- 서버 모드로 실행하면 C2(서버 컴파일러)만 쓰이는 식이었다.

  혼합 모드(mixed mode)
  - 가상 머신에서 인터프리터와 컴파일러를 함께 사용하는 방식

  해석 모드(interpreted mode)
  - 컴파일러가 전혀 개입하지 않는다.

  컴파일 모드(compiled mode)
  - 컴파일을 완료한 후 코드를 실행한다.
  - 단, 컴파일 모드라도 컴파일이 실패하면 여전히 인터프리터가 실행에 개입해야 한다

계층형 컴파일 도입
- JIT 컴파일러가 바이트코드를 네이티브 코드로 컴파일하려면 시간이 걸리며, 일반적으로 최적화를 더 많이 할수록 컴파일도 오래 걸린다.
- 더 많이 최적화된 코드로 컴파일하기 위해 인터프리터가 성능 모니터링(프로파일링) 정보를 수집할 수 있는데, 이 작업 역시 해석과 실행 단계 속도에 영향을 준다.
- 프로그램 시작 응답 속도와 운영 효율 사이에서 최상의 균형을 찾기 위해 핫스팟 가상 머신은 컴파일 서브시스템에 계층형 컴파일 기능을 추가했다.
  - 계층 0 ~ 4(책 참고)
- 빠르게 컴파일할 때는 클라이언트 컴파일러를 사용하고, 성능을 더 높여야 할 때는 서버 컴파일러를 사용한다.
- 우선 클라이언트 컴파일러로 간단한 최적화를 해 놓고, 복잡한 최적화는 느긋하게 마무리하는 방식도 가능하다.

### 컴파일 대상과 촉발 조건
핫 코드
- 런타임에 JIT 컴파일러가 컴파일하는 대상

핫 코드의 가장 대표적인 유형
1. 여러 번 호출되는 메서드
2. 여러 번 실행되는 순환문의 본문

  도대체 몇 버 실행되어야 '여러 번'이라고 할 수 있을까?
  => 핫스팟 탐지(특정 코드 블록이 핫코드인지 그래서 JIT 컴파일을 촉발시커야 하는지 판단하는 동작)
    - 샘플 기반 핫스팟 코드 탐지
      - 각 스레드의 호출 스택 상단을 샘플링하여 특정 메서드 또는 메서드의 일부가 자주 발견되면 해당 메서드를 핫 메서드로 간주한다
      - 구현이 쉽고 효율적이며 메서드 호출 관계를 쉽게 파악할 수 있는 방식이다.
      - 하지만 메서드의 핫한 정도를 정확하게 알기는 어렵고 스레드 블로킹 등의 외부 요인이 핫스팟 탐지를 방해하기 쉽다.
    
    - 카운터 기반 핫스팟 코드 탐지
      - 각 메서드와 코드 블록에 대한 카운터를 설정하고 나서 개별 횟수를 기록한다. 그러다가 실행횟수가 문턱 값을 초과하면 핫 메서드로 간주한다.
      - 메서드 각각에 대한 카운터를 설정하고 유지해야 해서 구현하기가 더 번거롭고, 메서드 호출 관계도 직접 얻을 수 없다.
      - 반면 더 정화하고 엄격한 결과를 얻을 수 있다.

    => J9은 샘플 방식. 핫스팟 가상 머신은 카운터 방식을 사용.

온스택 치환
- 메서드가 실행되는 도중에, 즉 해당 메서드의 스택 프레임이 여전히 스택에 존재하는 상태에서 메서드가 치환됨

메서드 호출 카운터에 의한 JIT 컴파일 촉발
- 이 카운터에는 메서드가 호출된 횟수가 기록된다
- 기본 문턱값은 클라이언트 모드에서 1500회이고 서버 모드에서는 1만 회다. 원한다면 매개 변수로 직접 설정할 수 있다.
- JIT 컴파일은 백그라운드에서 비동기로 진행한다. 컴파일이 완료되면 메서드의 호출 진입점 주소가 시스템에 의해 자동으로 새 값으로 덮어써지고, 그다음 호출부터는 컴파일된 버전이 사용된다.

백 에지 카운터에 의한 JIT 컴파일 촉발
- 백 에지 카운터는 특정 순환문의 본문 코드가 실행되는 횟수를 계산한다.
- 백 에지 횟수를 계산하는 목적은 온스택 치환 컴파일을 촉발하기 위해서다.

### 컴파일 과정
- 기본적으로 JIT 컴파일은 백그라운드에서 별도 스레드가 진행하며, 컴파일이 완료될 때까지는 인터프리터가 프로그램 실행을 이어 간다.

클라이언트 컴파일러의 컴파일 과정

서버 컴파일러의 컴파일 과정

## AOT 컴파일러

## 컴파일러 최적화 기법

## 실전: 그랄 컴파일러 깊이 이해하기
