# 6장 클래스 파일 구조
> 클래스 파일을 구성하는 다양한 요소와 각 요소의 정의, 데이터 구조, 용도를 자세히 살펴 본다.

> 자바 코드와 클래스 파일 코드를 예로들어 클래스 데이터를 실제로 저장하고 내용에 접근하는 방법을 알 수 있다.

> 이를 기반으로 다음 7장에서 가상 머신 실행 엔진이 바이트코드 스트림을 동적으로 해석하고 실행하는 과정을 알아봄으로써 가상 머신 실행 엔진에 대해 더 깊이 이해할 수 있다.

## 들어가며
컴퓨터는 0과 1만 인식할 수 있다.
우리가 작성한 프로그램이 컴퓨터에서 실행되려면 먼저 컴파일러를 실행해서 0과 1로 구성된 바이너리 형식으로 변환해야 한다.
하지만 가상 머신이 출현하면서 그 위에서 동작하는 수많은 프로그래밍 언어가 등장했고, 프로그램을 네이티브 코드로 컴파일하지 않아도 되는 길이 생겼다.
그리고 점점 더 많은 프로그래밍 언어가 운영 체제나 기계어에 종속되지 않는, 플랫폼 독립적 저장 형식을 선택하고 있다.

## 플랫폼 독립을 향한 초석
자바 가상 머신은 플랫폼 독립성과 언어 독립성을 제공한다.
- 플랫폼 독립성
  - 자바 가상 머신이 다양한 플랫폼(운영 체제)을 지원하고, 모든 가상 머신이 동일한 저장 형식(바이트 코드)을 지원한다는 사실이 플랫폼 독립성의 핵심이다.
- 언어 독립성
  - 언어 독립성을 보장하는 핵심은 가상 머신과 바이트 코드 저장 형식이다.
  - 자바, 코틀린, 스칼라 등의 언어로 작성된 프로그램을 해당 언어의 컴파일러를 통해 바이트코드로 바꿔 클래스 파일(*.class)로 저장할 수 있으면 가상 머신을 통해 실행할 수 있다.

## 클래스 파일의 구조
모든 클래스 파일은 각각 하나의 클래스 또는 인터페이스를 정의한다.

이번 장에서는 클래스나 인터페이스가 반드시 따라야 하는 형식을 '클래스 파일 형식'으로 지칭할 것이다.

- 클래스 파일
  - 믈래스 파일은 바이트를 하나의 단위로 하는 이진 스트림 집합체다. 각 데이터 항목이 정해진 순서에 맞게, 구분 기호 없이 조밀하게 나열된다. 그래서 클래스 파일 전체가 낭비되는 공간 없이 프로그램을 실행하는 데 꼭 필요한 데이터로 채워진다.
  - 1바이트가 넘는 데이터 항목은 바이트 단위로 분할되며, 이때 큰 단위의 바이트가 먼저 저장되는 빅 엔디언 방식으로 표현된다.
  - <<자바 가상 머신 명세>>에 따르면 클래스 파일에 데이터를 저장하는 데는 C 언어의 구조체와 비슷한 의사 구조(pseudo structure)를 이용한다. 이 의사 구조에는 '부호 없는 숫자'와 '테이블'이라는 두 가지 데이터 타입만 존재한다.

    - 부호 없는 숫자(unsigned number)
      - 기본 데이터 타입을 표현한다.
      - u1, u2, u4, u8은 각각 1바이트, 2바이트, 4바이트, 8바이트를 뜻한다.
      - 숫자, 인덱스 참조, 수량 값을 기술하거나 UTF-8로 인코딩된 문자열 값을 구성할 수 있다.

    - 테이블
      - 여러 개의 부호 없는 숫자나 또 다른 테이블로 구성된 복합 데이터 타입을 표현한다.
      - 구분이 쉽도록 테이블 이름은 관례적으로 '_info'로 끝난다.
      - 테이블은 계층적으로 구성된 복합 구조의 데이터를 설명하는 데 사용된다.
      - 클래스 파일 전체는 본질적으로 테이블이며 구조는 다음과 같다.

- 클래스 파일 구조
  ```
  ClassFile {
      u4                magic;                                //매직 넘버
      u2                minor_version;                        //클래스 파일 마이너 버전
      u2                major_version;                        //클래스 파일 메이저 버전
      u2                constant_pool_count;                  //상수 풀
      cp_info           constant_pool[constant_pool_count-1];
      u2                access_flags;                         //접근 플래그
      u2                this_class;                           //클래스 인덱스
      u2                super_class;                          //부모 클래스 인덱스
      u2                interfaces_count;                     //인터페이스 인덱스
      u2                interfaces[interfaces_count];         //얘는 왜 _info가 아닐까??
      u2                fields_count;
      field_info        fields[fields_count];                 //필드 테이블
      u2                methods_count;
      method_info       methods[methods_count];               //메서드 테이블
      u2                attributes_count;
      attribute_info    attributes[attributes_count];         //속성 테이블
  }
  ```
  - 같은 타입의 데이터 여러 개를 표현할 때 그 개수가 정해져 있지 않다면 개수를 알려 주는 타입이 바로 앞에 등장한다.
    - *_count 형태의 항목들이 여기 속한다.
    - [개수 + 개수만큼의 데이터 타입] 형태를 해당 타입의 '컬렉션'이라고 한다.
  - 클래스 구조는 구분자가 없기 때문에 구조 정의의 데이터 항목은 데이터가 저장되는 바이트 순서(byte ordering), 각 바이트의 의미, 길이, 순서가 모두 엄격하게 제한되며 변경할 수 없다.
  - 클래스 파일의 바이트 순서는 빅 엔디언이다.
    - 빅 엔디언은 가장 큰 단위의 바이트가 가장 낮은 주소에, 가장 작은 단위의 바이트가 가장 높은 주소에 저장된다.
    - 반대 순서로 저장하는 방식은 리틀 엔디언이라 한다. 현재 x86이 리틀 엔디언을 이용하는 대표적인 아키텍처다.
    - 빅 엔디언만 고집하는 아키텍처도 많지는 않고, 현재 파워(Power), AArch64, RISC-V 등 대부분의 주류 프로세서는 엔디언 방식을 변환할 수 있는 바이 엔디언(Bi Endian) 명령어 집합 아키텍처다.

매직 넘버
- 모든 클래스 파일의 처음 4바이트는 매직 넘버로 시작한다. 매직 넘버는 가상 머신이 허용하는 클래스 파일인지 여부를 빠르게 확인하는 용도로만 쓰인다.
- 클래스 파일의 매직 넘버는 `0xCAFEBABE`다.

클래스 파일의 버전
- 매직 넘버 다음의 4바이트는 클래스 파일의 다음 4바이트는 클래스 파일의 버전 번호다.
- 자바 버전 번호는 45부터 시작한다.
- 상위 버전 JDK는 하위 버전을 인식할 수 있지만, 하위 버전 JDK에서 상위 버전의 클래스 파일을 실행할 수는 없다.

상수 풀
- 클래스 파일 구조에서 다른 클래스와 가장 많이 연관된 부분으로, 클래스 파일의 자원 창고라 할 수 있다. 차지하는 공간이 대체로 가장 크다.
- 클래스 파일에서 가장 먼저 등장하는 테이블 타입 데이터 항목이다.
- 상수 풀에 들어 있는 상수의 수는 고정적이지 않으므로 상수 풀 항목들에 앞서 항목 개수를 알려주는 u2 타입 데이터가 필요하다.
  - 클래스 파일 구조에서 오직 상수 풀만이 개수를 1부터 센다. 그 외에 인터페이스 인덱스 컬렉션, 필드 테이블 컬렉션, 메서드 테이블 컬렉션 등의 원소 개수는 모두 0부터 센다.
  - 클래스 파일 설계자가 0번째 상수를 비운 이유는, 상수 풀 인덱스를 가리키는 데이터에서 '상수 풀 항목을 참조하지 않음'을 표현해야 하는 특수한 경우에 인덱스를 0으로 설정하도록 했기 때문이다.
- 상수 풀에 담기는 상수 유형은 리터럴과 심벌 참조 두 가지다.
  - 리터럴은 자바 언어 수준에서 이야기하는 상수(final로 선언된 문자열이나 상수)와 비슷한 개념이다.
  - 심벌 참조는 컴파일과 관련된 개념으로, 다음 유형의 상수들이 포함된다.
    - 모듈에서 익스포트하거나 임포트하는 패키지
    - 클래스와 인터페이스의 완전한 이름
    - 필드 이름과 서술자
    - 메서드 이름과 서술자
    - 메서드 핸들과 메서드 타입
    - 동적으로 계산되는 호출 사이트와 동적으로 계산되는 상수
  - 자바에서 링크는 가상 머신이 클래스 파일을 로드할 때 동적으로 이루어진다(상수 풀에서 심벌 참조들을 가져온다). 그런 다음 클래스가 생성되거나 구동할 때 해석하여 실제 메모리 주소로 변환한다. 따라서 가상 머신이 필드와 메서드의 심벌 참조를 런타임에 변환하지 않으면 각 항목의 실제 메모리 주소를 알 수 없다.
  - 상수 풀 안의 상수 각각이 모두 테이블인데, JDK 21 기준으로 총 17가지 상수 타입이 존재한다.
  - 상수 풀이 가장 복잡한 데이터인 이유는 17가지 상수 타입 각각의 데이터 구조가 완전히 독립적인데다가, 공통점이나 연관성이 딱히 없기 때문이다.
  - 클래스 파일에서 메서드와 필드 등의 이름을 기술하는 데 CONSTANT_Utf8_info 타입 상수를 참조하는데, 이 상수의 최대 길이가 결국 자바 메서드와 필드 이름의 최대 길이를 규정한다는 뜻이다. 최대 길이는 length의 최댓값, 즉 u2 타입이 표현할 수 있는 최댓값인 65535다. 따라서 자바 프로그램에서 변수나 메서드 이름의 길이가 64KB를 넘으면 컴파일되지 않는다.

접근 플래그
  - 상수 풀 다음의 2바이트는 현재 클래스(또는 인터페이스)의 접근 정보를 식별하는 접근 플래그다.
  - 현재 클래스 파일이 표현하는 대상이 클래스인지, 인터페이스인지, public인지, abstract인지, 클래스인 경우 final인지 등의 정보가 담긴다.

클래스 인덱스, 부모 클래스 인덱스, 인터페이스 인덱스

필드 테이블

메서드 테이블

속성 테이블

## 바이트코드 명령어 소개


## 설계는 공개, 구현은 비공개
<<자바 가상 머신 명세>>는 모든 자바 가상 머신이 지켜야 하는 약속이다. 자바 프로그램을 어떤 형태(클래스 파일 형식)로 저장하고, 어떤 명령어(바이트코드 명령어 집합)를 사용해서 실행해야 하는지 정의하고 있다. 이렇게 정의된 약속을 지킴으로써, 자바 프로그램은 어떤 회사의 자바 플랫폼을 사용하든지, 어떤 하드웨어나 운영 체제에서 실행하든지 안전하게 상호 운영될 수 있다.

클래스 파일을 정확하게 읽을 수 있고 그 안의 의미 체계도 완벽하게 유지하는 한, 가상 머신 구현자는 구현 방식을 자유롭게 선택할 수 있다. 외부에서 봤을 때 명세대로만 보인다면 내부에서 클래스 파일을 어떻게 처리하는지는 온전히 구현자에게 달려 있다.

가상 머신 구현자는 이러한 확장성을 십분 활용하여 고성능, 적은 메모리 소비, 훌륭한 이식성을 갖춘 가상 머신을 구현할 수 있다.

## 클래스 파일 구조의 진화
클래스 파일의 구조가 애초부터 확장을 고려해 설계된 덕분에 모든 개선이 새로운 내용을 추가하는 형태로 이루어질 수 있었다.
