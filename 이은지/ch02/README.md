# 2장 자바 메모리 영역과 메모리 오버플로
> 메모리 누수나 오버플로 문제가 발생했을 때, 이를 해결하려면 가상 머신의 메모리 관리 방식을 이해할 필요가 있다.
먼저 그 시작으로, 자바 가상 머신이 관리하는 다양한 메모리 영역과 각 영역의 역할, 관리 대상, 발생할 수 있는 문제들을 살펴보자.
> 

# 런타임 데이터 영역

![이미지 출처: [책] JVM 밑바닥까지 파헤치기(p60, 그림 2-1)](./assets/runtime_data_areas.jpg)

## 프로그램 카운터

- 프로그램 카운터는 현재 실행 중인 스레드의 바이트코드 줄 번호를 저장하는 작은 메모리 영역입니다. 자바 가상 머신에서 멀티스레딩은 각 스레드가 CPU 코어를 교대로 사용하기 때문에, 정확한 위치 복원을 위해 각 스레드마다 독립적인 프로그램 카운터가 필요합니다.
- 자바 메서드를 실행할 때는 프로그램 카운터에 바이트코드 명령어의 주소가 기록되며, 네이티브 메서드를 실행할 때는 `Undefined` 상태로 남습니다.
- 이 영역은 `OutOfMemoryError`가 발생하지 않는 유일한 메모리 영역입니다.

## 자바 가상 머신 스택

- 자바 가상 머신 스택은 각 스레드에 고유하게 할당되는 메모리 영역으로, 스레드와 함께 생성되고 삭제됩니다. 이 스택은 자바 메서드를 실행하는 동안 필요한 메모리 모델을 제공합니다.
- 각 메서드가 호출될 때 자바 가상 머신은 스택 프레임을 생성하여 지역 변수 테이블, 피연산자 스택, 동적 링크, 메서드 반환값 등의 정보를 저장합니다. 스택 프레임은 메서드 실행의 기본 데이터 구조로, 메서드 호출 시 `push`되고 메서드 종료 시 `pop`됩니다.
    
    ### 스택 프레임 구조
    
    ![이미지 출처: [책] JVM 밑바닥까지 파헤치기(p397, 그림 8-1)](./assets/stack_frame.jpg)
    
    - 스택 프레임은 메서드 실행 도중 사용되는 중요한 데이터 구조입니다.
    - 지역 변수 테이블에는 기본 데이터 타입(`boolean`, `byte`, `char`, `short`, `int`, `float`, `long`, `double`), 객체 참조, 반환 주소 타입이 저장됩니다.
    - 이 데이터들은 슬롯 단위로 저장되며, 대부분의 데이터 타입은 슬롯 하나(32비트)를 차지하지만, `double`과 같은 64비트 데이터는 슬롯 두 개를 차지합니다.
    - 지역 변수 테이블은 컴파일 과정에서 필요한 공간이 할당되며, 메서드 실행 중에는 그 크기가 변하지 않습니다.
- 스택 깊이가 허용된 한도를 초과하면 `StackOverflowError`가 발생합니다.
- 스택을 동적으로 확장할 수 있는 경우, 확장 시 메모리가 부족하면 `OutOfMemoryError`가 발생합니다. 핫스팟 가상 머신에서는 스택 용량을 동적으로 확장하지 않으므로, 이 오류는 발생하지 않습니다.

## 네이티브 메서드 스택

- 네이티브 메서드 스택은 자바 가상 머신 스택과 유사하지만, 자바 메서드가 아닌 네이티브 메서드를 실행할 때 사용됩니다.
- 이 스택도 가상 머신 스택과 동일하게 스택 깊이가 초과되면 `StackOverflowError`를, 스택 확장에 실패하면 `OutOfMemoryError`를 던질 수 있습니다.

## 자바 힙

- 자바 힙은 자바 애플리케이션에서 객체 인스턴스를 저장하는 가장 큰 메모리 영역입니다.
- 모든 스레드가 공유하며, 가상 머신이 구동될 때 생성됩니다.
- 주요 목적은 객체 인스턴스와 배열을 저장하는 것입니다.
- 가비지 컬렉터가 힙을 관리하며, 주로 세대별 컬렉션 이론을 기반으로 힙을 신세대, 구세대 등으로 나누어 효율적인 메모리 회수와 할당을 돕습니다.
    - 이와 관련된 용어로 '에덴 공간', '생존자 공간' 등이 있습니다. 그러나 이러한 영역 구분은 필수가 아니라, 가비지 컬렉터 설계에 따라 다를 수 있습니다.
- 객체 할당을 효율적으로 하기 위해 힙은 스레드 로컬 할당 버퍼(TLAB)로 나뉘며, 논리적으로는 연속된 메모리로 간주됩니다. 대부분의 가상 머신은 큰 객체를 물리적으로도 연속된 공간에 할당하여 성능을 최적화합니다.
- 자바 힙은 크기를 고정하거나 확장 가능하게 구현할 수 있으며, 현대의 대부분 가상 머신은 확장 가능한 형태로 구현되어 있습니다.
- 힙 공간이 부족하고 확장할 수 없을 경우 `OutOfMemoryError`가 발생합니다.

## 메서드 영역

- 메서드 영역은 자바 가상 머신에서 모든 스레드가 공유하는 메모리 영역으로, 타입 정보, 상수, 정적 변수, JIT 컴파일된 코드 캐시 등을 저장합니다.
- 논리적으로는 자바 힙의 일부로 간주되지만, 자바 힙과 구분하기 위해 '논힙(non-heap)'이라고도 불립니다.
- JDK 7까지는 핫스팟 가상 머신에서 메서드 영역이 영구 세대로 구현되어 가비지 컬렉터의 수집 대상이었습니다.
    - 이는 메서드 영역 관리의 단순화를 도왔지만, 메모리 오버플로우 위험을 높였습니다. 영구 세대의 최대 크기는 `XX:MaxPermSize`로 제한되었으며, 성능 문제를 유발할 수 있었습니다.
- JDK 8에서는 영구 세대가 완전히 제거되고, 메타스페이스라는 새로운 방식으로 네이티브 메모리에 메서드 영역이 구현되었습니다. 메타스페이스는 필요에 따라 동적으로 확장되어 이전보다 더 유연한 메모리 관리를 제공합니다.
- 메서드 영역이 부족할 경우 `OutOfMemoryError`가 발생할 수 있습니다.

## 런타임 상수 풀

- 런타임 상수 풀은 자바 가상 머신의 메서드 영역 일부로, 클래스 파일에 포함된 다양한 상수와 심벌 참조 정보를 저장합니다. 가상 머신이 클래스를 로드할 때 이러한 정보를 런타임 상수 풀에 저장하여, 메모리 효율성과 성능을 높입니다.
- 클래스 파일의 상수 풀과 달리 런타임 상수 풀은 동적으로 새로운 상수를 추가할 수 있습니다. 예를 들어, `String` 클래스의 `intern()` 메서드는 런타임에 문자열을 상수 풀에 추가하여 중복 생성을 방지하고 메모리 사용을 최적화합니다.
- Java 8부터 메서드 영역은 메타스페이스(Metaspace)로 대체되었으며, 문자열 상수 풀도 메타스페이스 내에서 관리됩니다.
    - 메타스페이스는 네이티브 메모리를 사용해 메서드 영역을 확장하여 더 유연한 메모리 관리가 가능합니다.
- 하지만 상수 풀의 공간이 부족하면 `OutOfMemoryError`가 발생할 수 있습니다.

## 다이렉트 메모리

- 다이렉트 메모리는 자바 가상 머신의 관리 영역에 속하지 않지만, 자주 사용되는 메모리이며 `OutOfMemoryError`의 원인이 될 수 있어 중요합니다.
- JDK 1.4에서 도입된 NIO는 힙이 아닌 네이티브 메모리를 직접 할당하며, `DirectByteBuffer` 객체를 통해 이 메모리에 접근합니다. 이를 통해 힙과 네이티브 메모리 간 데이터 복사를 피할 수 있어 성능을 크게 개선할 수 있습니다.
- 다이렉트 메모리는 자바 힙 크기의 제약을 받지 않지만, 시스템의 총 메모리 용량(물리 메모리, 스왑 파티션, 페이징 파일 등)과 프로세서가 다룰 수 있는 주소 공간을 넘을 수는 없습니다.
- 서버 관리자가 가상 머신의 메모리 크기(`Xmx`)만 고려하고 다이렉트 메모리를 간과하는 경우, 사용되는 모든 메모리 영역의 합이 시스템 한계를 넘어서면 `OutOfMemoryError`가 발생할 수 있습니다.

# **핫스팟 가상 머신에서의 객체**

## **객체 생성 과정**

1. **메모리 할당**
    - `new` 키워드를 사용하면 가상 머신은 힙에서 객체를 담을 메모리를 할당합니다.
    - 힙이 규칙적인 경우 포인터 밀치기 방식으로 메모리를 할당하고, 규칙적이지 않을 경우 여유 목록에서 적절한 블록을 찾아 할당합니다.
    - 멀티스레딩 환경에서 메모리 할당 방식
        - **메모리 할당 동기화:** 메모리 할당을 원자적으로 수행하기 위해 비교 및 교환(CAS)과 실패 시 재시도 방식을 사용하여 안전하게 메모리를 갱신합니다.
        - **스레드 로컬 할당 버퍼(TLAB):** 각 스레드에 자바 힙 내의 작은 전용 메모리 공간(TLAB)을 미리 할당하여, 스레드가 독립적으로 메모리를 사용할 수 있도록 합니다. TLAB이 부족해지면 동기화를 통해 새로운 버퍼를 할당받습니다. 가상 머신에서 TLAB 사용 여부는 `XX:+/-UseTLAB` 매개변수로 설정할 수 있습니다.
            
            ![이미지 출처: [책] JVM 밑바닥까지 파헤치기(p69, 그림 2-3)](./assets/use_tlab.jpg)
            
2. **메모리 초기화**
    - 스레드 로컬 할당 버퍼를 사용한다면 초기화는 TLAB 할당 시 미리 수행한다.
        - 자바 코드에서 객체의 인스턴스 필드를 초기화하지 않고도 사용할 수 있는 이유가 바로 이 단계 덕이다.
    - 할당된 메모리는 0으로 초기화되어 객체의 인스턴스 필드는 기본값을 가집니다.
3. **객체 헤더 설정**
    - 객체의 메타 정보(클래스 정보, 해시 코드, GC 세대 등)를 객체 헤더에 저장합니다.
4. **생성자 호출(클래스의 <init>() 메서드)**
    - 마지막으로 생성자를 호출해 객체를 초기화하고, 자바 프로그램에서 사용할 수 있는 객체가 완성됩니다.
        - 자바 컴파일러는 new 키워드를 발견하면 바이트코드 명령어인 new와 invokespecial로 변환한다.
            - new
                - 자바 가상 머신 관점에서 객체 생성(메모리 할당 등)
            - invokespecial
                - 자바 프로그램 관점에서 객체 생성(생성자 실행)

## **객체 메모리 구조**

핫스팟 가상 머신은 객체를 힙에 저장할 때, 객체 헤더, 인스턴스 데이터, 정렬 패딩의 세 부분으로 나누어 저장합니다.

![이미지 출처: [책] JVM 밑바닥까지 파헤치기(p72, 그림 2-4)](./assets/object_memory_layout.jpg)

- **객체 헤더**: 클래스 정보, 해시 코드, 락 상태 등의 메타 데이터를 저장합니다.
- **인스턴스 데이터**: 프로그램에서 정의한 필드 값들을 저장합니다.
- **정렬 패딩**: 객체의 메모리 주소를 8바이트의 배수로 맞추기 위한 패딩입니다.

## **객체 접근 방식**

### 핸들 방식

![이미지 출처: [책] JVM 밑바닥까지 파헤치기(p75, 그림 2-5)](./assets/reference_by_handle.jpg)

- 힙에 핸들을 저장하고, 핸들이 실제 객체를 가리키는 방식입니다.
- 객체 이동 시 참조 주소를 변경할 필요가 없어 안정적입니다.

### 다이렉트 포인터 방식

![이미지 출처: [책] JVM 밑바닥까지 파헤치기(p76, 그림 2-6)](./assets/reference_by_direct_pointer.jpg)

- 참조에 객체의 실제 주소를 저장하는 방식으로, 핸들을 경유하지 않아 더 빠르게 접근할 수 있습니다.
- 핫스팟 가상 머신은 주로 이 방식을 사용합니다.

# 참고

- https://docs.oracle.com/javase/specs/
- https://d2.naver.com/helloworld/1230
- https://openjdk.org/jeps/122
- https://johngrib.github.io/wiki/java8-why-permgen-removed/
- [https://becomeweasel.tistory.com/entry/JVM의-Java-8에서의-변화](https://becomeweasel.tistory.com/entry/JVM%EC%9D%98-Java-8%EC%97%90%EC%84%9C%EC%9D%98-%EB%B3%80%ED%99%94)