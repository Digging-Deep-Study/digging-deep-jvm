# 클래스 로딩 메커니즘
> 로딩, 검증, 준비, 해석, 초기화

## 들어가며
가상 머신의 클래스 로딩 메커니즘
  - JVM은 클래스를 설명하는 데이터 클래스를 파일로부터 메모리로 읽어 들이고 그 데이터를 검증, 변환, 초기화하고 나서 최종적으로 가상 머신이 곧바로 사용할 수 있는 자바 타입을 생성한다

자바의 동적 로딩과 동적 링킹
  - 컴파일 시 링크까지 해야 하는 언어들과 달리 자바 언어에서는 클래스 로딩, 링킹, 초기화가 모두 프로그램 실행 중에 이루어 진다
  
  - 장점은 자바 애플리케이션의 높은 확장성과 유연성을 가능하게 한다
  
  - 단점은 AOT 컴파일에 제약이 생기고 클래스 로딩을 거치느라 실행 성능이 살짝 떨어진다

## 클래스 로딩 시점

타입의 생애 주기
- `로딩(Loading)` -> [ `검증(Verification)` -> `준비(Preparation)` -> `해석(Resolution)` ]: 링킹(Linking) -> `초기화(Initialization)` -> `사용(Using)` -> `언로딩(Unloading)`
  
  - 로딩, 검증, 준비, 초기화, 언로딩은 반드시 순서대로 진행해야 한다
  
  - 해석 단계는 자바 언어의 런타임 바인딩(동적 바인딩 또는 늦은 바인딩)을 지원하기 위해서 초기화 후에 시작할 수 있다

타입 초기화를 촉발하는 6가지 시나리오 - 타입에 따른 능동 참조(active reference)
  - 바이트코드 명령어인 new, getstatic, putstatic, invokestatic을 만났을 때 해당 타입이 아직 초기화되어 있지 않은 경우
  
    - new 키워드로 객체의 인스턴스 생성
  
    - 타입의 정적 필드를 읽거나 설정(단, final로 지정된 정적 필드는 컴파일타임에 상수 풀에 채워지므로 제외)
  
    - 타입의 정적 메서드 호출
  
  - Class 클래스나 java.lang.reflect 패키지 등 표준 클래스 라이브러리에서 제공하는 메서드를 사용할 때 해당 타입이 아직 초기화되어 있지 않은 경우
  
  - 클래스를 초기화할 때 상위 클래스가 초기화되어 있지 않은 경우 상위 클래스 초기화
  
  - 가상 머신은 구동 직후 사용자가 지정한 메인 타입(main() 메서드를 포함하는 클래스나 인터페이스)을 찾아 실행하는데, 이때 메인 타입의 초기화를 먼저 시작
  
  - REF_getStatic, REF_putStatic, REF_invokeStatic, RET_newInvokeSpecial 타입 메서드 핸들을 해석해 얻은 java.lang.invoke.MethodHandle 인스턴스를 호출할 때 해당하는 클래스가 초기화되어 있지 않은 경우
  
  - 인터페이스에 디폴트 메서드를 정의한 경우, 해당 인터페이스를 직간접적으로 구현한 클래스가 초기화 될 때 인터페이스부터 초기화

타입 초기화를 촉발하지 않는 그 외의 모든 참조 방식 - 수동 참조(passive reference)
  
  - 클래스 필드를 통한 수동 참조 예시 1: 하위 클래스를 통해 부모 클래스의 정적 필드를 참조하는 경우, 하위 클래스 초기화는 필요 없다(코드 생략)

  - 클래스 필드를 통한 수동 참조 예시 2: 배열 정의에서 클래스를 참조하는 경우, 클래스 초기화를 촉발하지 않는다

  - 클래스 필드를 통한 수동 참조 예시 3: 클래스의 상수를 참조하는 경우, 상수는 컴파일 과정에서 호출하는 클래스의 상수 풀에 저장되므로, 상수를 정의한 클래스로의 직접적인 참조가 없다. 따라서 상수를 정의한 클래스의 초기화를 촉발하지 않는다.

인터페이스 초기화와 클래스 초기화의 차이
  - 클래스를 초기화하려면 먼저 상위 클래스를 모두 초기화 해야하는 반면, 인터페이스 초기화에는 상위 인터페이스 초기화가 필요 없다. 상위 인터페이스 초기화는 해당 상위 인터페이스가 실제로 사용될 때 이루어진다.

## 클래스 로딩 처리 과정

JVM이 클래스를 로딩하는 전체 과정
  - 로딩 -> 검증 -> 준비 -> 해석 -> 초기화

### 로딩
  1. 완전한 이름을 보고 해당 클래스를 정의하는 바이너리 바이트 스트림을 가져온다

  2. 바이트 스트림으로 표현된 정적인 저장 구조를 메서드 영역에서 사용하는 런타임 데이터 구조로 변환한다.

  3. 로딩 대상 클래스를 표현하는 java.lang.Class 객체를 힙 메모리에 생성한다. 이 Class 객체는 애플리케이션이 메서드 영역에 저장된 타입 데이터를 활용할 수 있게 하는 통로가 된다.

로딩 단계는 JVM에 내장된 부트스트랩 클래스 로더를 사용하거나 사용자 정의 클래스 로더를 사용하여 수행할 수 있다. 단, 배열 클래스는 클래스 로더가 생성하지 않고 JVM이 직접 메모리에 동적으로 생성한다.

### 검증
링킹 과정 중 첫 번째 단계로, 다음과 같은 목적을 가진다.
  1. 클래스 파일의 바이트 스트림에 담긴 정보가 <<자바 가상 머신 명세>>에서 규정한 모든 제약을 만족하는지 확인

  2. 이 정보를 코드로 변환해 실행했을 때 JVM 자체의 보안을 위협하지 않는지 확인

검증 단계는 엄격하게 진행해야 JVM이 악성코드로부터 자신을 보호할 수 있다. 2011년에 발표된 자바 SE 7용 <<자바 가상 머신 명세>>에서 제약 조건과 검증 규칙이 구체화 됐다.
  
  1. 파일 형식 검증
    
    - 바이트 스트림이 클래스 파일 형식에 부합하고 현재 버전의 가상 머신에서 처리될 수 있는지 확인한다

    - 이 단계의 검증은 바이너리 바이트 스트림을 대상으로 이루어지며, 검증을 통과하면 바이트 스트림이 JVM 메모리 중 메서드 영역에 저장된다.(이후 단계에서는 바이트 스트림을 직접 읽지 않는다.)

  2. 메타데이터 검증

    - 바이트 코드로 설명된 정보의 의미를 분석하여 서술된 정보가 <<자바 언어 명세>>의 요구 사항을 충족하는지 확인한다

    - 클래스의 메타데이터 정보에 대한 의미론적 검증을 수행하여 <<자바 언어 명세>>와 일치하지 않는 메타데이터가 섞여 있지 않은지 확인하는 것이 목적이다

  3. 바이트코드 검증

    - 클래스의 메서드 본문(클래스 파일의 Code 속성)을 분석하여, 메서드가 런타임에 가상 머신의 보안을 위협하는 동작을 하지 않는지 확인한다

    - 전체 검증 과정에서 가장 복잡한 단계로, 데이터 흐름과 제어 흐름을 분석하여 프로그램의 의미가 적법하고 논리적인지 확인하는 것이 목적이다

    - 메서드 본문이 바이트코드 검증을 통과했다고 해서 100% 안전하다는 보장은 없다. 프로그램 로직에 버그가 있는지 여부를 완벽하게 검증해 내는 범용 프로그래을 작성하는 건 불가능하다는 뜻이다

    - 최신 버전 클래스 파일(JDK 6 이상으로 빌드한 클래스 파일)에서는 데이터 흐름 분석과 검증에 무조건 타입 검사기가 사용된다고 봐도 좋다

  4. 심벌 참조 검증
    
    - 현재 클래스가 참조하는 특정 외부 클래스, 메서드, 필드, 그 외 자원들에 접근할 권한이 있는지 본다

    - 해석을 제대로 수행할 수 있는지 확인하는 것이 목적이다

    - 해당 검증 단계는 매우 중요하지만 필수는 아니기 때문에 `-Xverify:none` 매개 변수를 지정하여 검증을 건너 뛸 수 있다
      - 이미 오랜 기간 반복 사용하여 신뢰할 수 있는 코드의 경우 검증을 생략사면 JVM이 클래스를 로딩하는 데 시간을 제법 단축할 수 있다

### 준비

  - 클래스 변수(정적 변수)를 메모리에 할당하고 초깃값을 설정한다

  - 개념적으로는 메모리를 메서드 영역에 할당해야 하지만, 메서드 영역 자체는 논리적 영역이다.

    - JDK 7까지 핫스팟에서는 메서드 영역을 영구 세대에 구현하여 논리적인 개념과 일치했다. 하지만 JDK 8부터는 클래스 변수가 클래스 객체와 함께 자바 힙에 저장된다.

  - 준비 단계에서는 인스턴스 변수가 아닌 클래스 변수만 할당된다.
    
    - 인스턴스 변수는 객체가 인스턴스화될 때 객체와 함께 자바 힙에 할당된다.

  - 준비 단계에서 클래스 변수에 할당하는 초깃값은 해당 데이터 타입의 제로 값이다.

    - 준비 단계에서는 어떠한 자바 메서드도 아직 실행되지 않은 상태이기 때문에, 값을 할당하는 일은 "클래스 초기화 단계"에 가서 이루어진다.

  - 클래스 변수에 final을 추가하면 가상 머신은 준비 단계 때 ConstantValue 속성이 지정한 값을 할당한다

### 해석

- JVM이 상수 풀의 심벌 참조를 직접 참조로 대체하는 과정이다

  - 클래스 또는 인터페이스 해석

  - 필드 해석

  - 메서드 해석

  - 인터페이스 메서드 해석 

### 초기화

- 클래스 로딩의 마지막 단계로, JVM이 사용자 클래스에 작성된 자바 프로그램 코드를 실행하기 시작한다.

- 앞서 준비 단계에서 모든 변수에 시스템이 정의한 초깃값인 0을 할당했는데, 초기화 단계에서는 클래스 변수와 기타 자원을 개발자가 프로그램 코드에 기술한 대로 초기화 한다

- 더 직관적으로 표현하자면 초기화 단계란 클래스 생성자인 <clinit>() 메서드를 실행하는 단계다.

## 클래스 로더

## 자바 모듈 시스템

