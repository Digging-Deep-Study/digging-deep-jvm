# 3장 가비지 컬렉터와 메모리 할당 전략
> 지우는 놈, 없앨 놈, 남길 놈

## 3.1 들어가며

### 가비지 컬렉션과 메모리 할당의 내부를 이해해야 하는 이유

- 다양한 메모리 오버플로와 누수 문제를 해결해야 하거나, 가비지 컬렉션이 더 높은 동시성을 달성하는 데 방해되는 상황에 효과적으로 대응할 수 있다.

### 가비지 컬렉터

- 런타임 시점에 동적으로 할당된 힙과 메서드 영역의 메모리를 효율적으로 관리하는 데 중점을 둔다.

## 3.2 대상이 죽었는가?

### 가비지 컬렉터가 힙을 청소하려면

- 먼저 어떤 객체가 사용 중인지, 어떤 객체가 더 이상 사용되지 않는지 판단해야 한다.

### 참조 카운팅 알고리즘

- 객체의 참조 횟수를 통해 객체가 살아 있는지 판단하는 방식이다.
- 간단하고 효율적이지만, 순환 참조 문제와 같은 한계로 인해 `JVM`에서는 사용되지 않는다.

### 도달 가능성 분석 알고리즘

- `GC 루트`로부터 접근 가능한지를 탐색하여 객체의 생존 여부를 판단하는 방식이다.
    - `GC 루트`에서 시작해 참조 체인을 따라 연결된 객체를 탐색하며, `GC 루트`로부터 도달 불가능한 객체는 더 이상 사용되지 않는 것으로 간주되어 회수 대상이 된다.
- 자바, C# 등 오늘날의 주류 프로그래밍 언어들은 모두 객체 생사 판단에 도달 가능성 분석 알고리즘을 사용한다.
- 자바에서 `GC 루트`로 이용할 수 있는 객체
    1. 가상 머신 스택에서 참조하는 객체: 메서드의 매개 변수, 지역 변수, 임시 변수 등
    2. 메서드 영역에서 정적 필드로 참조하는 객체: 클래스의 정적 변수
    3. 메서드 영역에서 상수로 참조되는 객체: 문자열 테이블 안의 참조
    4. 네이티브 메서드 스택에서 `JNI`가 참조하는 객체
    5. `JVM` 내부에서 쓰이는 참조: 기본 데이터 타입의 Class 객체, 예외 객체, 시스템 클래스 로더
    6. 동기화 락 객체: `synchronized` 키워드로 잠겨 있는 모든 객체
    7. `JVM` 내부 상황을 반영하는 `JMXBean`: `JVMTI`에 등록된 콜백, 로컬 코드 캐시 등
- 객체는 서로 다른 메모리 영역에 있는 객체를 참조할 수 있으므로, 연관된 모든 영역을 포함하여 도달 가능성을 분석해야 정확한 결과를 얻을 수 있다.

### 참조 이야기

- `JDK 1.2` 이전
    - 객체의 상태는 ‘참조됨’와 ‘참조되지 않음’ 두 가지로 표현되었다.
    - ‘버리기 아까운’ 객체를 표현할 방법이 없어 객체를 효율적으로 관리하기 어려움.
- `JDK 1.2` 부터 확장된 참조 유형
    - 강한 참조(strong reference)
        - 가장 일반적인 참조 형태로, 코드에서 객체를 직접 참조하는 방식이다. `Object obj = new Object();`
        - 강한 참조가 남아 있는 객체는 절대 가비지 컬렉션으로 회수되지 않는다.
    - 부드러운 참조(soft reference)
        - 필수는 아니지만 유용한 객체를 표현한다.
        - 메모리가 부족할 경우, `GC`에 의해 우선 회수된다.
        - `SoftReference` 클래스를 통해 구현된다.
    - 약한 참조(weak reference)
        - 부드러운 참조보다 더 약한 연결로, `GC`가 실행될 때 항상 회수 대상이 된다.
        - 메모리가 충분하더라도 약한 참조만 남은 객체는 `GC`에서 바로 제거된다.
        - `WeakReference` 클래스를 통해 구현된다.
    - 유령 참조(phantom reference)
        - 참조 중에 가장 약한 형태로, 객체의 생명 주기에 아무런 영향을 주지 않는다.
        - 객체의 회수 시점을 감지하기 위해 사용된다.
        - `PhantomReference` 클래스로 구현된다.

### 살았나 죽었나?

- 도달 가능성 분석 알고리즘으로 ‘도달 불가능’으로 판단한 객체라도 반드시 죽는 건 아니다. 확실한 사망 선고는 두 번의 표시(marking) 과정을 통해 결정된다.
- `finalize()` 메서드를 실행해서 부활할 수 있는 기회가 있지만, `finalize()` 는 실행 비용이 높고 동작이 불확실성이 크기 때문에 JDK 9부터 폐기 대상으로 지정되었다.
- `finalize()`는 사용하지 말자!

### 메서드 영역의 가비지 컬렉션

- 메서드 영역도 가비지 컬렉션 대상이 될 수 있지만, 비용 효율이 좋지 않아 일부 JVM은 이를 완벽하게 지원하지 않는다. 예를 들어, ZGC는 JDK 11에서는 클래스 언로딩을 지원하지 않았고 JDK 12부터 지원했다.
- 메서드 영역의 가비지 컬렉션의 주요 회수 대상
    - 더 이상 사용되지 않는 상수
        - 상수 풀의 리터럴이나 심볼이 참조되지 않으면 회수됨
    - 더 이상 사용되지 않는 클래스(다음 세 조건을 모두 만족해야 회수하도록 허용된다)
        1. 해당 클래스의 인스턴스가 모두 회수됨
        2. 해당 클래스를 읽어 들인 클래스 로더가 회수됨
        3. 해당 클래스에 해당하는 java.lang.Class 객체가 참조되지 않고, 리플렉션 사용도 없음
- JVM은 클래스 회수를 허용하지만 필수로 강제하지는 않는다.
    - HotSpot JVM에서는 클래스 회수 여부 제어를 위한 -Xnoclassgc 매개 변수를 제공한다.
- 리플렉션, 동적 프락시, CGLib과 같은 바이트코드 프레임워크를 많이 사용하는 경우나 JSP를 동적으로 생성하고 클래스 로더를 자주 사용자화하는 OSGi 환경 등에서는 JVM이 타입 언로딩을 지원해야 메서드 영역의 메모리 압박을 완화할 수 있다.

## 3.3 가비지 컬렉션 알고리즘

> 세대 단위 컬렉션 이론을 포함한 몇 가지 알고리즘에 담긴 아이디어와 발전 과정에 집중한다.

세대 단위 컬렉션 이론, 마크- 스윕 알고리즘, 마크 - 카피 알고리즘, 마크 - 컴팩트 알고리즘

## 3.4 핫스팟 알고리즘 상세 구현

> 다양한 가비지 컬렉터를 이해하는 데 필요한 기초 지식을 쌓는다.

루트 노드 열거, 안전 지점, 안전 지역, 기억 집합과 카드 테이블, 쓰기 장벽, 동시 접근 가능성 분석

## 3.5 클래식 가비지 컬렉터

> JDK 7 업데이트 4부터 JDK 11 공식 릴리스까지 오라클 JDK의 핫스팟 가상 머신에 포함된 모든 가비지 컬렉터를 다룬다.

시리얼 컬렉터, 파뉴 컬렉터, 패러렐 스캐빈지 컬렉터, 시리얼 올드 컬렉터, CMS 컬렉터, G1 컬렉터

## 3.6 저지연 가비지 컬렉터

> ZGC와 셰넌도어는 지연 시간 최소화를 목표로 하는 최첨단 컬렉터들이다.
> 

셰넌도어, ZGC